[["index.html", "Causal Inference Using R 本稿の目的", " Causal Inference Using R yamaguchi 2022-10-31 本稿の目的 本稿では、統計的因果推論の理論とRでの実装についてまとめる。統計的因果推論には大きく分けて潜在的結果変数の枠組みを用いるRubin流(星野, 2009; 高橋, 20212)と構造的因果モデル(SCM: Structual Causal Model)と因果ダイアグラム(もしくはグラフィカルモデル)を用いるPearl流に分けられる。本稿では、主に後者に焦点を当てて解説を行う。 参考にした書籍やウェブサイトは、以下のものである。 Causal inference in statistics: A primer (邦訳「入門統計的因果推論」)(Pearl et al. 2016) \\(\\rightarrow\\) 本稿のベース The book of why: the new science of cause and effect. (邦訳「因果推論の科学」)(Pearl and Mackenzie 2018) \\(\\rightarrow\\) 一般向け書籍。数式を用いない解説や事例が豊富。因果推論の科学ができるまでの歴史についても学べる。 岩波データサイエンス vol. 3 因果推論ー実世界のデータから因果を読む (岩波データサイエンス慣行委員会, 2016) \\(\\rightarrow\\) バックドア基準をはじめ因果推論のトピックに関する短くわかりやすい解説 統計的因果推論―回帰分析の新しい枠組み― (宮川, 2004) Take a Risk: 林岳彦の研究メモ ウェブサイト References "],["パッケージの読み込み.html", "0. パッケージの読み込み", " 0. パッケージの読み込み 因果ダイアグラムの分析には主にdagittyパッケージ(Textor et al. 2016)を、描画には’dagitty’をベースに作られたggdagパッケージ(Barrett 2018)を用いる。 それぞれの関数の使い方は以下のサイトを参照。 dagitty ggdag library(tidyverse) ## ── Attaching packages ─────────────────────────────────────── tidyverse 1.3.1 ── ## ✔ ggplot2 3.3.6 ✔ purrr 0.3.4 ## ✔ tibble 3.1.7 ✔ dplyr 1.0.9 ## ✔ tidyr 1.2.0 ✔ stringr 1.4.0 ## ✔ readr 2.1.2 ✔ forcats 0.5.1 ## ── Conflicts ────────────────────────────────────────── tidyverse_conflicts() ── ## ✖ dplyr::filter() masks stats::filter() ## ✖ dplyr::lag() masks stats::lag() library(dagitty) library(ggdag) ## ## Attaching package: &#39;ggdag&#39; ## The following object is masked from &#39;package:stats&#39;: ## ## filter library(patchwork) library(easystats) ## # Attaching packages: easystats 0.5.2 (red = needs update) ## ✖ insight 0.18.2 ✖ datawizard 0.5.1 ## ✖ bayestestR 0.12.1 ✖ performance 0.9.2 ## ✖ parameters 0.18.2 ✖ effectsize 0.7.0.5 ## ✔ modelbased 0.8.5 ✖ correlation 0.8.2 ## ✖ see 0.7.2 ✖ report 0.5.1 ## ## Restart the R-Session and update packages in red with `easystats::easystats_update()`. library(GGally) ## Registered S3 method overwritten by &#39;GGally&#39;: ## method from ## +.gg ggplot2 library(ppcor) ## Warning: package &#39;ppcor&#39; was built under R version 4.2.1 ## Loading required package: MASS ## ## Attaching package: &#39;MASS&#39; ## The following object is masked from &#39;package:patchwork&#39;: ## ## area ## The following object is masked from &#39;package:dplyr&#39;: ## ## select library(ggsci) ## ## Attaching package: &#39;ggsci&#39; ## The following objects are masked from &#39;package:see&#39;: ## ## scale_color_material, scale_colour_material, scale_fill_material References "],["なぜ統計的因果推論が必要か.html", "1 なぜ統計的因果推論が必要か", " 1 なぜ統計的因果推論が必要か 私たちが研究を行う上で立てるリサーチクエスチョンの多くは、「ニホンザルの群れの凝集性はオスの攻撃に影響を受けるのか」、「食物状況はオスの性行動に影響しているか」というようなものである。これらの問いは、2つ(あるいはそれ以上)の変数間の相関関係(「\\(X\\)が小さい/大きいほど、\\(Y\\)も小さい/大きい」)ではなく、因果関係(「\\(X\\)を小さく/大きくすると、\\(Y\\)も小さく/大きくなる」)に関する問いである。すなわち、私たちの研究の多くは、データから変数間の因果関係(およびその効果量)を推測する(= 統計的因果推論)ことがゴールにある。よって、どのようにすれば因果推論を行うことができるかを学ぶことは、私たちの研究の根本にかかわる重要なことだと考えられる。 統計的因果推論についての知識がなければ、実際に得られたデータから因果関係を推測することは難しい。特に研究者が変数への操作や介入を行えない観察研究では、複数の要因が複雑に影響し合っていることが珍しくないため、殊更に困難である。そのような状況では、変数間でみられる相関関係が実際の因果関係と一致しないことが良く起こるからである。 以下の例を考えてみよう。 ニホンザルのコドモにおいて、ある期間に食べた1日当たりの平均食物摂取量(乾燥重量で\\(X\\)g)がその期間における遊び時間割合(\\(Y\\)%)に影響しているかを調べたいとする。\\(X\\)と\\(Y\\)、そして年齢(\\(Z\\))の間に図1の間のような因果関係があるとする(もちろん架空の関係である)。なお、丸は各変数を、矢印は因果関係を表す(詳細は次章を参照)。 Figure 1: X, Y, Zの間の因果関係 このような関係の下ではどのようなデータが得られるだろうか。シミュレーションによって図1のような因果関係を持つデータを生成し(詳細はRのコードを参照)、\\(X\\)と\\(Y\\)の関係を散布図にしたものが、図2である。 この図からは「食物摂取量(\\(X\\))が多いほど、遊び時間割合(\\(Y\\))が少ない」という負の相関関係が読み取れる。この関係は、「食物摂取量(\\(X\\))が多くなると、遊び時間割合(\\(Y\\))が多くなる」という実際の因果関係(図1参照)とは正負が逆になってしまっている。つまり、\\(X\\)と\\(Y\\)の相関関係だけを見るだけでは、その因果関係を適切に推測できないのである。 ## `geom_smooth()` using formula &#39;y ~ x&#39; Figure 2: 平均食物摂取量(X)と遊び時間割合(Y)の関係。直線は回帰直線を表す。 なぜこのようなことが起こるのだろうか。それは、\\(X\\)と\\(Y\\)の因果関係を適切に推測するためには、その両方に影響している第3の変数\\(Z\\)(年齢)を考慮しなくてはならないからである。年齢ごとに\\(X\\)と\\(Y\\)の関係を見てみると、実際の因果関係と一致した方向の正の相関(「\\(X\\)が多いほど\\(Y\\)も多い」)が確認できるようになる。 ## `geom_smooth()` using formula &#39;y ~ x&#39; Figure 3: 年齢(Z)を考慮した平均食物摂取量(X)と遊び時間割合(Y)の関係。直線は年齢ごとの回帰直線を表す。 このように、データの背後にある変数間の因果構造(= データ生成過程)を考慮しなければ、データから適切な因果推論を行うことはできない。 この後見ていくように、データの因果構造によってどのような変数を考慮すべきかは異なってくる。本稿では、構造的因果モデル(SCM)と因果ダイアグラムという2つのツールを用いることで、いかなる因果構造を持つデータについても適切に因果推論を行う手法を学んでいく。 学ぶのは主に以下の3点についてである。 因果関係を正確に記述する方法(第2章) 因果モデルの構造をデータの特徴に関連付ける方法(第3章) モデルとデータに含まれる因果関係の組み合わせから結論を導く方法(第4~5章) "],["構造的因果モデルと因果ダイアグラムの基礎.html", "2. 構造的因果モデルと因果ダイアグラムの基礎 2.1 構造的因果モデル(SCM) 2.2 因果ダイアグラムの概要 2.3 因果ダイアグラムの描き方 2.4 因果ダイアグラムの基礎 2.5 独立と従属", " 2. 構造的因果モデルと因果ダイアグラムの基礎 2.1 構造的因果モデル(SCM) 変数間の因果関係を記述するためには、データセットにある変数間の因果関係についての仮定を正式に記述する必要がある。 そこで、構造的因果モデル(SCM: Structural Causal Model)を導入する。 SCMは、以下の3つによって記述される。 \\(V\\): その変動理由がモデル内で記述される変数(内生変数)の集合 \\(U\\): その変動理由がモデル内で記述されない変数(外生変数)の集合 \\(F\\): モデル内の他の変数によって内生変数の値を決定する関数の集合 内生変数は少なくとも1つの外生変数を含む関数を用いて記述される(=少なくとも1つの外生変数の子孫である)。一方で、外生変数は他の変数によって記述できない(=他の変数の子孫ではない)。すなわち、すべての外生変数の値が分かれば、関数\\(F\\)により全ての内生変数の値が正確に決定される。 例: 教育レベル(\\(X\\))と職務経験(\\(Y\\))による給料(\\(Z\\)) \\(U = \\lbrace X, Y \\rbrace, V = \\lbrace Z \\rbrace, F = \\lbrace f_Z \\rbrace\\) \\[ \\begin{aligned} f_Z: Z &amp;= 2X + 3Y \\end{aligned} \\] 因果の定義(Pearl et al. 2016) SCM内で\\(Y\\)の値を決定する関数に\\(X\\)が使われるとき、\\(X\\)は\\(Y\\)の直接原因であるという。\\(X\\)が\\(Y\\)の直接原因であるか、\\(Y\\)の原因の直接原因であるとき、\\(X\\)は\\(Y\\)の原因であるという。上の例では、\\(X\\)と\\(Y\\)は\\(Z\\)の直接原因である。 ひとことメモ 因果関係の定義には様々な流儀があり、ここではPearl et al. (2016)の定義を紹介した。 前述の定義とほとんど同じであるが、林・黒木(2016)は以下のように定義している。 「要因\\(X\\)を人為的に変化させた(介入した)とき、要因\\(Y\\)も変化する」とき「要因\\(X \\rightarrow Y\\)の因果関係がある」と呼ぶ 2.2 因果ダイアグラムの概要 因果ダイアグラムとは、図1のように丸(記号は何でもよいが)と矢印を用いて変数間の因果構造を表したものである。矢印は因果関係を表し、それぞれのSCMには対応する因果ダイアグラムが必ず存在する。因果ダイアグラムを活用することで、定量的なデータに依ることなくモデルの中に存在する変数の関係を表現することができるので、因果推論を行う上で非常に重要なツールである。 先ほどの例を因果ダイアグラムで表すと以下のようになる。 Figure 4: 因果ダイアグラムの例 2.3 因果ダイアグラムの描き方 ここでは、Rでの因果ダイアグラムの描き方を解説する。 まずはノード(点)の名前と位置(x,y座標)を記したデータフレーム(あるいはtibble)を作成する。 dag1 &lt;- tibble(name = c(&quot;A&quot;,&quot;B&quot;,&quot;C&quot;,&quot;D&quot;), x = c(1, 2, 3, 2), y = c(2, 2, 2, 1)) その後、gadify()でノード間の関係を記述する。 y ~ xはy &lt;- xを表す。 x1 ~~ x2は x1 &lt;-&gt; x2を表す。 dagified_dag1 &lt;- dagify(A ~ B, C ~ B, D ~ A + C, ##暴露変数の指定ができる exposure = &quot;C&quot;, ## 結果変数の指定ができる outcome = &quot;D&quot;, coords = dag1) グラフの描画に必要な情報が書き込まれるよう。 dagified_dag1 ## dag { ## A [pos=&quot;1.000,2.000&quot;] ## B [pos=&quot;2.000,2.000&quot;] ## C [exposure,pos=&quot;3.000,2.000&quot;] ## D [outcome,pos=&quot;2.000,1.000&quot;] ## A -&gt; D ## B -&gt; A ## B -&gt; C ## C -&gt; D ## } tidy_dagitty()でデータフレームの形で出力もできる。 tidy_dagitty(dagified_dag1) ## # A DAG with 4 nodes and 4 edges ## # ## # Exposure: C ## # Outcome: D ## # ## # A tibble: 5 × 8 ## name x y direction to xend yend circular ## &lt;chr&gt; &lt;int&gt; &lt;int&gt; &lt;fct&gt; &lt;chr&gt; &lt;int&gt; &lt;int&gt; &lt;lgl&gt; ## 1 A 1 2 -&gt; D 2 1 FALSE ## 2 B 2 2 -&gt; A 1 2 FALSE ## 3 B 2 2 -&gt; C 3 2 FALSE ## 4 C 3 2 -&gt; D 2 1 FALSE ## 5 D 2 1 &lt;NA&gt; &lt;NA&gt; NA NA FALSE 最後に、ggplot()を用いてダイアグラムを描画する。 ggdagパッケージに含まれる関数を使用する。 ggplot(dagified_dag1, aes(x = x, y=y, xend = xend, yend = yend))+ ## ノード、文字、エッジの設定。Dのみ色を変える geom_dag_point(aes(color = name == &quot;D&quot;), alpha = 1/2, size = 10.5, show.legend = F)+ geom_dag_text(color = &quot;black&quot;)+ geom_dag_edges()+ scale_color_manual(values = c(&quot;steelblue&quot;, &quot;orange&quot;))+ ## 座標を消す scale_x_continuous(NULL, breaks = NULL, expand = c(.1, .1)) + scale_y_continuous(NULL, breaks = NULL, expand = c(.1, .1)) + theme_minimal() + theme(panel.grid = element_blank()) Figure 5: 作成した因果ダイアグラム 特にこだわりがなければ、ggdag()で容易に描ける。 theme_dag()で最小限のテーマ(目盛や背景を削除)にしてくれる。 ggdag(dagified_dag1, node_size =10, text_size = 3)+ theme_dag() Figure 6: ggdag()で描いた因果ダイアグラム 2.4 因果ダイアグラムの基礎 有向辺(方向のあるエッジ)の始点を親、終点を子と呼ぶ。 Figure 7: ノードの親子 また、3つ以上のノードがあり、2つの有向辺が共に入ってくるノードや、2つの有向辺が共に出ていくノードがない場合(下図のようなとき)、これを有向道と呼ぶ。 有向道上の最初のノードは、道上のすべてのノードの祖先である(下図で、CはAの祖先、AはCの子孫(=孫)である)。 Figure 8: ノードの親・子・孫 Rでは、dagittyパッケージでこれを求められる。 図5の因果ダイアグラムを用いて求めてみる。 親 ## 親 parents(dagified_dag1,&quot;D&quot;) ## [1] &quot;A&quot; &quot;C&quot; ## 子 children(dagified_dag1, &quot;B&quot;) ## [1] &quot;A&quot; &quot;C&quot; ## 祖先 ancestors(dagified_dag1, &quot;D&quot;) ## [1] &quot;D&quot; &quot;C&quot; &quot;B&quot; &quot;A&quot; ## 子孫 descendants(dagified_dag1, &quot;B&quot;) ## [1] &quot;B&quot; &quot;C&quot; &quot;D&quot; &quot;A&quot; また、特定の2つのノード間の有向道は以下のように求められる。 directed = Fとすると有向道以外の道も調べられる。 paths(dagified_dag1, &quot;B&quot;, &quot;D&quot;, directed = T)$path ## [1] &quot;B -&gt; A -&gt; D&quot; &quot;B -&gt; C -&gt; D&quot; 有向道があるノードからスタートして、それ自身に戻ってくるとき、その道とグラフは巡回的という。 例えば、以下の二つのグラフは巡回的である。 巡回的でないグラフを非巡回的であるという。 Figure 9: 巡回的なグラフの例 2.5 独立と従属 2つの変数\\(X\\)と\\(Y\\)は、以下が成り立つときにそれぞれがとりうる全ての値\\(x\\)と\\(y\\)について独立という。すなわち、XとYが独立のとき、変数Yの値がなんであろうと、\\(P(X = x)\\)の値は変わらない(= 相関がない)。 \\[ P(X = x|Y = y) = p(X = x) \\] 独立は記号を用いて以下のように表せる。 \\[ X \\mathop{\\perp\\!\\!\\!\\!\\perp} Y \\] また、確率変数\\(Z\\)の任意の値が与えられたときに\\(X\\)と\\(Y\\)が全ての\\(x\\)、\\(y\\)について独立のとき、\\(X\\)と\\(Y\\)は\\(Z\\)の下で条件付き独立であるという。 以下のようにあらわす。 \\[ X \\mathop{\\perp\\!\\!\\!\\!\\perp} Y|Z \\] 因果ダイアグラム上で独立または条件付き独立であるノードは、impliedConditionalIndependencies()を用いて以下のように求められる(例. 図5について)。 impliedConditionalIndependencies(dagified_dag1) ## A _||_ C | B ## B _||_ D | A, C なお、独立でない2変数は従属であるという。 ひとことメモ 実際の分析では、例えば以下のような場合に\\(Z\\)について条件付けしたことになる。 ある\\(Z\\)の値のデータのみを抽出して分析する 偏相関係数: \\(Z\\)の影響を排除して他の2変数相関係数を算出する 回帰分析: 説明変数に\\(Z\\)を加えて回帰分析を行う References "],["因果ダイアグラムの因果推論への応用.html", "3. 因果ダイアグラムの因果推論への応用 3.1 因果ダイアグラムの基本3パターン 3.1.1 連鎖経路(chain) 3.1.2 分岐経路(fork) 3.1.3 合流点(collider) 3.2 d分離性(d-separation) 3.3 モデル検定と因果探索", " 3. 因果ダイアグラムの因果推論への応用 この章では、因果ダイアグラムを因果推論へ応用する方法を学ぶ。 具体的には、以下の手順によって仮定した因果モデル(SCM)が正しいものか検証することになる。 あるSCMと因果ダイアグラムが正しいと仮定したとき、変数間の独立/従属関係がどのようになるかを調べる(3.1~3.2) 実際のデータにおける独立/従属関係が、仮定した因果ダイアグラムから想定される独立/従属関係と一致するか確認することで、SCMで仮定した因果関係が正しいかを検証し、必要な場合は修正する(3.3) 3.1 因果ダイアグラムの基本3パターン まず、因果ダイアグラムに現れる基本3パターンをまとめる。実際の因果ダイアグラムはより複雑だが、どのようなダイアグラムも基本的にはこの3パターンの因果構造の組み合わせで表すことができる。 本節ではそれぞれのパターンで、どのようなときに因果ダイアグラムに含まれる2変数が独立/従属になるかを学ぶ。これによって以下のことが可能になる。 相関(あるいは従属)\\(\\neq\\)因果になるのがどのようなときなのかを理解できるようになる いかなる因果ダイアグラムにおいても、変数間の独立/従属関係を知ることができるようになる 3.1.1 連鎖経路(chain) 3.1.1.1 概要 図10のように3つのノードと2つのエッジがあり、中央の変数に1つのノードが入ってきて、また別のノードがそこから出ていく構成を連鎖経路(chain)と呼ぶ。 \\(X\\)と\\(Y\\)は\\(Z\\)の原因である \\(Y\\)を\\(X \\rightarrow Z\\)の因果関係における中間変数(あるいは媒介因子)という dag4 &lt;- tibble(name = c(&quot;X&quot;,&quot;Y&quot;,&quot;Z&quot;), x = c(1.5, 2, 2.5), y = c(2.5, 2, 1.5)) dagified_chain &lt;- dagify(Y ~ X, Z ~ Y, coords = dag4) Figure 10: 連鎖経路の例 連鎖経路では以下が成り立つ。 \\(X\\)と\\(Y\\)、\\(Y\\)と\\(Z\\)、\\(X\\)と\\(Z\\)は特異な例を除けばそれぞれ従属である \\(X\\)と\\(Z\\)は、\\(Y\\)の下で条件付き独立 2は、\\(Y\\)で条件づけると、因果関係がある\\(X\\)と\\(Y\\)の関連が消えてしまうことを示している。 2はRでも確かめられる。 impliedConditionalIndependencies(dagified_chain) ## X _||_ Z | Y 3.1.1.2 連鎖経路の例 2は以下のような例で確かめられる。 \\(X\\)、\\(Y\\)、\\(Z\\)の間に以下のような関係(SCM)が成り立つとする。 ただし、\\(U_x\\)、\\(U_y\\)、\\(U_z\\)は平均0で標準偏差1の正規分布に従い、互いに独立とする(以後同様)。 \\[ \\begin{aligned} X &amp;= U_x\\\\ Y &amp;= \\frac{4}{5}X + U_y\\\\ Z &amp;= \\frac{2}{3}Y + U_z\\\\ \\end{aligned} \\] 上記のSCMは以下のようにも書き換えられる。 なお、\\(X \\sim Normal(0,1)\\)は\\(X\\)が平均0,標準偏差1の正規分布に従うことを表す。\\(i = 1, 2, ...,N\\)である。 \\[ \\begin{aligned} x_{i} &amp;\\sim Normal(0,1) \\\\ y_{i} &amp;\\sim Normal(\\frac{4}{5}x_{i},1) \\\\ z_{i} &amp;\\sim Normal(\\frac{2}{3}y_{i},1) \\\\ \\end{aligned} \\] 実際にデータを生成して分析してみる。 N &lt;- 10000 Ux &lt;- rnorm( N ); Uy &lt;- rnorm( N ); Uz &lt;- rnorm( N ) X &lt;- Ux Y &lt;- 4/5*X + Uy Z &lt;- 2/3*Y + Uz d &lt;- data.frame(X=X,Y=Y,Z=Z) \\(X\\)、\\(Y\\)、\\(Z\\)は互いに有意に相関している(\\(X\\),\\(Y\\),\\(Z\\)は互いに従属)。 ggpairs(d) Figure 11: 連鎖経路におけるX, Y, Zの間の関係 回帰分析(\\(Z \\sim X\\))をすると、\\(X\\)と\\(Z\\)は有意に関連している(\\(X\\)と\\(Z\\)は従属)。 model_parameters(lm(Z~X,d)) %&gt;% print_md() Parameter Coefficient SE 95% CI t(9998) p (Intercept) -6.99e-03 0.01 (-0.03, 0.02) -0.59 0.558 X 0.52 0.01 (0.50, 0.54) 43.80 &lt; .001 しかし、説明変数に\\(Y\\)も加えると(=\\(Y\\)で条件づけると)、\\(X\\)の係数はほぼ0になり、因果関係がある\\(X\\)と\\(Z\\)の関連は消失してしまう(\\(X\\)と\\(Z\\)は、Yの下で条件付き独立 )。 ▶ \\(Y\\)の値が分かれば、\\(Z\\)を予測するうえで\\(X\\)の値は関係なくなるから(\\(X\\)は\\(Y\\)通してしか\\(Z\\)に影響を与えていないので) model_parameters(lm(Z~X+Y,d)) %&gt;% print_md() Parameter Coefficient SE 95% CI t(9997) p (Intercept) -7.54e-03 0.01 (-0.03, 0.01) -0.75 0.451 X 3.56e-03 0.01 (-0.02, 0.03) 0.28 0.780 Y 0.65 0.01 (0.64, 0.67) 64.99 &lt; .001 なお、XとYの間の有向道が1つだけあり、それが連鎖経路であるとき、\\(X\\)と\\(Y\\)はその間のいずれの変数(1つでなくともよい)についても条件付き独立である。すなわち、下図で\\(X\\)と\\(W\\)は\\(Y\\)と\\(Z\\)いずれでの下でも条件付き独立になる。 Figure 12: 連鎖経路の例2 3.1.2 分岐経路(fork) 3.1.2.1 概要 図13のように、2つの変数に共通の変数が影響を与えているような構成を分岐経路(fork)と呼ぶ。またこのとき、\\(X\\)を交絡因子(変数)と呼ぶ。 dag5 &lt;- tibble(name = c(&quot;X&quot;,&quot;Y&quot;,&quot;Z&quot;), x = c(2, 1, 3), y = c(2, 1, 1)) dagify(Y ~ X, Z ~ X, coords = dag5) -&gt; dagified_fork Figure 13: 分岐経路の例 分岐経路では以下が成り立つ。 \\(X\\)と\\(Y\\)、\\(X\\)と\\(Z\\)、\\(Y\\)と\\(Z\\)は特異な例を除けばそれぞれ従属 \\(Y\\)と\\(Z\\)は\\(X\\)の下で条件付き独立 1は、交絡因子によって因果関係にない\\(Y\\)と\\(Z\\)の間に関連(相関)が生じてしまうことを示している。 2は、この関連は\\(X\\)で条件づけることによって消失することを示す。 これはRでも確かめられる。 impliedConditionalIndependencies(dagified_fork) ## Y _||_ Z | X 3.1.2.2 分岐経路の例 2を直観的に確かめるため、以下の例を考える。 \\(X\\)、\\(Y\\)、\\(Z\\)の間に以下のような関係(SCM)が成り立つと、\\(X\\)、\\(Y\\)、\\(Z\\)の関係は分岐経路で表せる。 \\(X\\)(＝気温)が\\(Y\\)(= アイスクリームの売上)と\\(Z\\)(= プール来場者数)に影響 \\(Y\\)と\\(Z\\)は互いに影響しない \\[ \\begin{aligned} X &amp;= U_x\\\\ Y &amp;= \\frac{5}{2}X + U_y\\\\ Z &amp;= \\frac{2}{3}X + U_z\\\\ \\end{aligned} \\] 上記のSCMは以下のようにも書ける。 ただし、\\(i = 1,2,...N\\)。 \\[ \\begin{aligned} x_{i} &amp;\\sim Normal(0,1) \\\\ y_{i} &amp;\\sim Normal(\\frac{5}{2}x_{i},1) \\\\ z_{i} &amp;\\sim Normal(\\frac{2}{3}x_{i},1) \\\\ \\end{aligned} \\] SCMをもとに実際にデータを生成してみる。 N &lt;- 10000 Ux &lt;- rnorm( N ); Uy &lt;- rnorm( N ); Uz &lt;- rnorm( N ) X &lt;- Ux Y &lt;- 5/2*X + Uy Z &lt;- 2/3*X + Uz d &lt;- data.frame(X=X,Y=Y,Z=Z) \\(X\\)、\\(Y\\)、\\(Z\\)は互いに有意に強く相関している(=\\(X\\),\\(Y\\),\\(Z\\)は互いに従属している)。 ggpairs(d) Figure 14: 分岐経路におけるX, Y, Zの間の関係 回帰分析(\\(Z \\sim Y\\))をすると、\\(Y\\)と\\(Z\\)は有意に関連している(\\(Y\\)と\\(Z\\)は従属)。 model_parameters(lm(Z~Y,d)) %&gt;% print_md() Parameter Coefficient SE 95% CI t(9998) p (Intercept) 5.90e-03 0.01 (-0.01, 0.03) 0.57 0.567 Y 0.23 3.80e-03 (0.22, 0.24) 59.90 &lt; .001 しかし、説明変数に\\(X\\)も加えると(=\\(X\\)で条件づけると)、\\(Y\\)の係数はほぼ0になり、\\(Y\\)と\\(Z\\)の関連は消失する(=\\(Y\\)と\\(Z\\)は\\(X\\)の下で条件付き独立)。すなわち、交絡が解消された。 model_parameters(lm(Z~X+Y,d)) %&gt;% print_md() Parameter Coefficient SE 95% CI t(9997) p (Intercept) 5.99e-03 0.01 (-0.01, 0.03) 0.60 0.550 X 0.64 0.03 (0.59, 0.69) 23.67 &lt; .001 Y 6.24e-03 0.01 (-0.01, 0.03) 0.62 0.535 3.1.3 合流点(collider) 3.1.3.1 概要 図15のようにあるノードに他の2つのノードからエッジが入ってきている構成を合流点(collider)と呼ぶ。 dag5 &lt;- tibble(name = c(&quot;X&quot;,&quot;Z&quot;,&quot;Y&quot;), x = c(1, 2, 3), y = c(2, 1, 2)) dagify(Z ~ X, Z ~ Y, coords = dag5) -&gt; dagified_collider Figure 15: 合流点の例 合流点では以下が成り立つ。 \\(X\\)と\\(Z\\)、\\(Y\\)と\\(Z\\)は特異な例を除けばそれぞれ従属 \\(X\\)と\\(Y\\)は独立 \\(X\\)と\\(Y\\)は\\(Z\\)の下で条件付き従属 1は自明であり、2もRで確かめられる。 impliedConditionalIndependencies(dagified_collider) ## X _||_ Y 3.1.3.2 合流点の例1 1と2は直観的に理解できるが、3が成り立つのはなぜだろうか？ 以下の例を考える。 ある大学の入学試験で以下のように合否を判定するとする 音楽試験の点数(\\(X\\))と学力試験の点数(\\(Y\\))の合計点で合否(\\(Z\\)、\\(X+Y &gt; 115\\)なら合格)を判定 \\(X\\)と\\(Y\\)には全く関連がない \\(U_X\\)と\\(U_y\\)はそれぞれ平均50、標準偏差10の正規分布に従う \\[ \\begin{aligned} X &amp;= U_x\\\\ Y &amp;= U_y\\\\ Z &amp;= \\left\\{ \\begin{array}{ll} 1(合格) &amp; (X + Y &gt; 115)\\\\ 0(不合格) &amp; (X + Y &lt; 115) \\end{array} \\right. \\end{aligned} \\] 上記のSCMは以下のように書き換えられる。 ただし、\\(i = 1,2,...N\\)。 \\[ \\begin{aligned} x_{i} &amp;\\sim Normal(50,10) \\\\ y_{i} &amp;\\sim Normal(50,10) \\\\ z &amp;= \\left\\{ \\begin{array}{ll} 1(合格) &amp; (x_{i} + y_{i} &gt; 115)\\\\ 0(不合格) &amp; (x_{i} + y_{i} &lt; 115) \\end{array} \\right. \\end{aligned} \\] 実際にこれに基づいてデータを生成して分布をみてみると、1と2が確かめられる。 合格者(\\(Z=1\\))の方が不合格者(\\(Z=0\\))より、\\(X\\)と\\(Y\\)がそれぞれ大きい(\\(X\\)と\\(Z\\)、\\(Y\\)と\\(Z\\)は従属) \\(X\\)と\\(Y\\)には相関がない(独立)。 N &lt;- 500 Ux &lt;- rnorm(N, mean = 50, sd = 10); Uy &lt;- rnorm(N, mean = 50, sd = 10); Uz &lt;- rnorm( N ) X &lt;- Ux Y &lt;- Uy Z &lt;- vector() for(i in 1:500){ if (X[i] + Y[i] &gt; 115){ Z[i] &lt;- &quot;1&quot; }else{ Z[i] &lt;- &quot;0&quot; } } d &lt;- data.frame(X=X,Y=Y,Z=Z) ggpairs(d) ## `stat_bin()` using `bins = 30`. Pick better value with `binwidth`. ## `stat_bin()` using `bins = 30`. Pick better value with `binwidth`. Figure 16: 合流点を含む経路におけるX, Y, Zの間の関係 ここで、\\(Z\\)で条件付けるとどうなるだろうか。例えば、合格者(\\(Z=1\\))のデータのみを抽出したとする。 青い直線は合格者のみのデータを抽出したときの回帰直線である。このとき、因果会計にない\\(X\\)と\\(Y\\)の間に相関が生じていることが分かる(= \\(X\\)と\\(Y\\)は\\(Z\\)の下で条件付き従属)。これを合流点バイアスという。 ## `geom_smooth()` using formula &#39;y ~ x&#39; Figure 17: 合流点バイアスの例 3.1.3.3 合流点の例2 なお、合流点だけでなく、合流点の子孫のいずれを条件した場合でも、独立した変数同士が従属になることがある。 以下の例を考える。 交尾期において、各観察日にニホンザルの群れに訪れる群れ外オスの数(\\(Z\\))は、その日の発情メスの数(\\(X\\))と気温(\\(Y\\))によって決まるとする。 また、メスがオスから攻撃される頻度(\\(W\\))は、その日に群れを訪れた群れ外オスの数(\\(Z\\))に依存するとする。 以下のSCMを考える。 \\[ \\begin{aligned} x_{i} &amp;\\sim Poisson(3.5)\\\\ y_{i} &amp;\\sim Normal(10,1.5)\\\\ z_{i} &amp;\\sim Poisson(0.8x_{i}+0.75y_{i}-2)\\\\ w &amp;\\sim Normal(0.4z_{i} + 1.2, 0.5) \\end{aligned} \\] SCMを因果ダイアグラムで表すと以下のようになる。 dag6 &lt;- tibble(name = c(&quot;X&quot;,&quot;Z&quot;,&quot;Y&quot;,&quot;W&quot;), x = c(1, 2, 3,2), y = c(2, 1.5, 2,1)) dagify(Z ~ X, Z ~ Y, W ~ Z, coords = dag6) -&gt; dagified_collider_b dagified_collider_b %&gt;% ggdag(node_size =10, text_size = 3)+ theme_dag() Figure 18: 合流点の例2 実際にこれに基づいてデータを生成して分布をみてみると、\\(X\\)と\\(Y\\)に有意な相関はない(=独立である)ことが確かめられる。また、\\(Z\\)と\\(W\\)はどちらも\\(X\\), \\(Y\\)と有意な相関がある(=従属)。 set.seed(191) N &lt;- 500 X &lt;- rpois(N, 3.5) Y &lt;- rnorm(N, 10, 1.5) Z &lt;- rpois(N, 0.8*X + 0.75*Y - 2) W &lt;- rnorm(N, 0.4*Z+1.2, 0.5) d &lt;- data.frame(X=X,Y=Y,Z=Z,W=W) ggpairs(d) Figure 19: 合流点の子を含む経路におけるX, Y, Z, Wの間の関係 一方、\\(Z\\)またはその子孫である\\(W\\)を統制した場合の\\(X\\)と\\(Y\\)の偏相関係数を調べると、いずれも小さいが有意な相関が現れる(=条件付き従属)。 \\(Z\\)を統制 pcor.test(d$X,d$Y,d$Z) ## estimate p.value statistic n gp Method ## 1 -0.1296674 0.003713279 -2.915352 500 1 pearson \\(W\\)を統制 pcor.test(d$X,d$Y,d$W) ## estimate p.value statistic n gp Method ## 1 -0.1068466 0.0169576 -2.395699 500 1 pearson 3.2 d分離性(d-separation) 一般的な因果モデル(ダイアグラム)は、以上で見た3つのパターンより複雑であることが多い。具体的には、多くのモデルにおいて変数間を結ぶ道は複数存在し、それぞれの道は様々な連鎖、分岐、合流点を通過している。 ここでは、このように複雑なモデルにおいても変数間の独立/従属を判断するため、前節までに学んだことをもとにd-分離(d-separation)という概念を導入する。２つのノード(変数)がd分離されるとき、それらの変数は独立であるといえる。 d分離の定義 以下の1または2が成り立つとき、グラフ上で道\\(p\\)がノードの集合\\(Z\\)にブロックされているという。 \\(p\\)は連鎖経路\\(A \\rightarrow B \\rightarrow C\\)または分岐経路\\(A \\leftarrow B \\rightarrow C\\)を含み、中央のノードが\\(Z\\)に含まれる(= \\(B\\)について条件付けしている) \\(p\\)は合流点\\(A \\rightarrow B \\leftarrow C\\)を含み、合流点\\(B\\)とその全ての子孫が\\(Z\\)に含まれない(= \\(Z\\)とその子孫で条件付けしない) \\(Z\\)が\\(X\\)と\\(Y\\)の間の道をすべてブロックするとき、\\(Z\\)が与えられた下で\\(X\\)と\\(Y\\)はd分離しているという。 一方で、\\(X\\)と\\(Y\\)がd分離されていないとき、\\(X\\)と\\(Y\\)はd連結であるという。 例1. 合流点とその子、分岐点を持つ因果ダイアグラム dag7 &lt;- tibble(name = c(&quot;X&quot;,&quot;Z&quot;,&quot;Y&quot;,&quot;W&quot;,&quot;Uz&quot;,&quot;Uw&quot;,&quot;Ux&quot;,&quot;Uy&quot;,&quot;U&quot;,&quot;Uu&quot;), x = c(3, 1, 4,2,1,2,3,4,2,0.5), y = c(3,3,3,2,4,3.5,4,4,1,1.5)) dagify(X ~ Ux, Z ~ Uz, Y ~ X + Uy, W ~ Z + Uw + X, U ~ W + Uu, coords = dag7) -&gt; dagified_dsep1 Figure 20: 合流点とその子、分岐点を持つ因果ダイアグラム \\(Z\\)と\\(Y\\)を結ぶ道は合流点 \\(W\\)を含むのでブロックされている(= d分離されている) が、\\(W\\)について条件付けすると、\\(Z\\)と\\(Y\\)はd連結になる(= 従属)。これは、\\(W\\)の子である\\(U\\)について条件付けしても同様。 しかし、\\(W\\)に加えて\\(X\\)も条件付けすると、\\(W \\leftarrow X \\rightarrow Y\\)の分岐経路がブロックされるので、\\(Z\\)と\\(Y\\)はd分離されたままである。 Rでは、\\(Z\\)と\\(Y\\)がそれぞれの変数で条件づけられたときにd分離されるかを以下のように調べられる。 ## Wで条件付け dseparated(dagified_dsep1, &quot;Z&quot;,&quot;Y&quot;, &quot;W&quot;) ## [1] FALSE ## WとXで条件付け dseparated(dagified_dsep1, &quot;Z&quot;,&quot;Y&quot;, c(&quot;W&quot;,&quot;X&quot;)) ## [1] TRUE 例2. 図20に\\(Z\\)と\\(Y\\)の間の分岐経路を加えたもの dag8 &lt;- tibble(name = c(&quot;X&quot;,&quot;Z&quot;,&quot;Y&quot;,&quot;W&quot;,&quot;Uz&quot;,&quot;Uw&quot;,&quot;Ux&quot;,&quot;Uy&quot;,&quot;U&quot;,&quot;Uu&quot;,&quot;T&quot;,&quot;Ut&quot;), x = c(3, 1, 4,2,1,1.8,2.25,4,2,0.5,2.5,2.5), y = c(3.3,3,3,2,4,3.2,3.2,4,1,1.5,4,4.5)) dagify(T ~ Ut, X ~ Ux, Z ~ T + Uz, Y ~ X + T + Uy, W ~ Z + Uw + X, U ~ W + Uu, coords = dag8) -&gt; dagified_dsep2 Figure 21: 先のグラフにZとYの間の分岐経路を加えたもの \\(Z\\)と\\(Y\\)の間に分岐経路ができたことで、何も条件付けなければ\\(Z\\)と\\(Y\\)は従属になる(= d連結)。 \\(T\\)について条件付ければ、\\(Z\\)と\\(Y\\)の間の道はブロックされ、d分離される。 \\(T\\)に加えて\\(W\\)について条件づけると、\\(Z \\leftarrow T \\rightarrow Y\\)はブロックされるが、\\(Z \\rightarrow W \\leftarrow X \\rightarrow\\)は開いてしまうので、d連結になる。 さらに\\(X\\)も加えて条件付けすれば、再びd分離される。 Rでも確かめられる。 ## Tで条件付け dseparated(dagified_dsep2, &quot;Z&quot;,&quot;Y&quot;, &quot;T&quot;) ## [1] TRUE ## TとWで条件付け dseparated(dagified_dsep2, &quot;Z&quot;,&quot;Y&quot;, c(&quot;T&quot;,&quot;W&quot;)) ## [1] FALSE ## T, W, Xで条件付け dseparated(dagified_dsep2, &quot;Z&quot;,&quot;Y&quot;, c(&quot;T&quot;,&quot;W&quot;,&quot;X&quot;)) ## [1] TRUE 練習問題 図22で隣接していない変数の組それぞれについて、どの変数の集合で条件付き独立となるか Figure 22: 練習問題1の因果ダイアグラム A. 答えは以下の8通りである。 \\(Y\\), \\(V\\), \\(U\\)は分岐経路であり、\\(Y\\)と\\(U\\)を結ぶ道は1つしかないので、\\(Y \\mathop{\\perp\\!\\!\\!\\!\\perp} U|V\\) \\(V\\), \\(U\\), \\(T\\)は連鎖経路であり、\\(V\\)と\\(T\\)を結ぶ道は1つずつしかないので、\\(V \\mathop{\\perp\\!\\!\\!\\!\\perp} T|U\\) \\(X\\), \\(R\\), \\(S\\), \\(T\\)は連鎖経路であり、道は一つしかない。よって、\\(X \\mathop{\\perp\\!\\!\\!\\!\\perp} T|R, X \\mathop{\\perp\\!\\!\\!\\!\\perp} T|S, X \\mathop{\\perp\\!\\!\\!\\!\\perp} S|R, R \\mathop{\\perp\\!\\!\\!\\!\\perp} T|S\\) \\(V\\)は\\(Y\\)と\\(T\\)のいずれの原因にもなっているので、\\(Y\\)と\\(T\\)はおそらく従属である。しかし、\\(U\\)で条件づけると\\(V\\)と\\(T\\)が独立になり、結果的に\\(V\\)の子である\\(Y\\)と\\(T\\)も独立になる(\\(Y \\mathop{\\perp\\!\\!\\!\\!\\perp} T|U\\)) \\(V\\)で条件づけると\\(Y\\)と\\(U\\)が独立になり、結果的に\\(U\\)の子である\\(T\\)も\\(Y\\)と独立になる(\\(Y \\mathop{\\perp\\!\\!\\!\\!\\perp}T|U\\)) Rでは、すべての独立/条件付き独立の変数の集合は以下のように求められる。 # impliedConditionalIndependencies(dagified_prac1) 図22のモデルからデータを生成し、線形方程式\\(Y = a + bX + cZ\\)をあてはめる。傾きbを0にするには\\(Z\\)にどの変数を選べばよいか。 A. \\(Z\\)の下で\\(X\\)と\\(Y\\)が条件付き独立(d分離)になればよい。\\(T\\)以外は条件づけてもd分離されるので、\\(T\\)以外ならどれでもよい。 ## 各変数で条件づけたときにXとYがd分離されるか調べる sapply( names(dagified_prac1), function(Z) dseparated(dagified_prac1,&quot;X&quot;,&quot;Y&quot;,Z) ) ## R S T U V X Y ## TRUE TRUE FALSE TRUE TRUE TRUE TRUE 実際にモデルからデータを生成して確認する。 d_prac1 &lt;- simulateSEM(dagified_prac1, # パス係数を0.7に設定する b.lower = 0.7, b.upper = 0.7, N = 5000) 確かに\\(T\\)で条件づけると\\(X\\)の係数は0でない。 lm(Y ~ X + T, data = d_prac1) %&gt;% model_parameters() %&gt;% print_md() Parameter Coefficient SE 95% CI t(4997) p (Intercept) 0.01 0.01 (-0.01, 0.04) 0.86 0.391 X -0.14 0.01 (-0.16, -0.11) -9.79 &lt; .001 T 0.40 0.01 (0.38, 0.43) 29.29 &lt; .001 他の変数(例えば\\(S\\)や\\(V\\))ではほぼ0になる。 lm(Y ~ X + S, data = d_prac1) %&gt;% model_parameters() %&gt;% print_md() Parameter Coefficient SE 95% CI t(4997) p (Intercept) 0.01 0.01 (-0.02, 0.04) 0.81 0.417 X -9.83e-05 0.02 (-0.03, 0.03) -6.09e-03 0.995 S 0.01 0.02 (-0.02, 0.05) 0.93 0.351 lm(Y ~ X + V, data = d_prac1) %&gt;% model_parameters() %&gt;% print_md() Parameter Coefficient SE 95% CI t(4997) p (Intercept) 6.84e-03 0.01 (-0.01, 0.03) 0.68 0.497 X 4.42e-03 0.01 (-0.02, 0.02) 0.44 0.660 V 0.70 0.01 (0.68, 0.71) 69.39 &lt; .001 図23で隣接していない変数の組それぞれについて、どの変数の集合で条件付き独立となるか Figure 23: 練習問題3の因果ダイアグラム A. 問1で挙げた組み合わせに加えて、以下でも条件付き独立になる。 \\(P\\mathop{\\perp\\!\\!\\!\\!\\perp}U|T\\) (連鎖経路) \\(P\\mathop{\\perp\\!\\!\\!\\!\\perp}V|T, P\\mathop{\\perp\\!\\!\\!\\!\\perp}V|U\\) (連鎖経路) \\(P\\mathop{\\perp\\!\\!\\!\\!\\perp}S|T\\) (連鎖経路) \\(P\\mathop{\\perp\\!\\!\\!\\!\\perp}R|S, P\\mathop{\\perp\\!\\!\\!\\!\\perp}R|T\\) (連鎖経路) \\(P\\mathop{\\perp\\!\\!\\!\\!\\perp}X|R,P\\mathop{\\perp\\!\\!\\!\\!\\perp}X|S, P\\mathop{\\perp\\!\\!\\!\\!\\perp}X|T\\) (連鎖経路) \\(P\\mathop{\\perp\\!\\!\\!\\!\\perp}Y|V,P\\mathop{\\perp\\!\\!\\!\\!\\perp}Y|U, P\\mathop{\\perp\\!\\!\\!\\!\\perp}Y|T\\) (分岐経路+連鎖経路) 以下でも確かめられる。 #impliedConditionalIndependencies(dagified_prac2) 図23のモデルで、方程式\\(Y = a + bX + cR + dS + eT + fP\\)をあてはめると、どの係数が0になるか。 A. \\(X,R,S,T,P\\)について、これらの変数が全て条件づけられたときに\\(Y\\)とd分離されるかを検討すればよい。\\(T\\)と\\(S\\)を除けばd分離されるので、係数が0になるのはそれらの変数である。 dseparated(dagified_prac2, &quot;Y&quot;, list(), c(&quot;X&quot;,&quot;R&quot;,&quot;S&quot;,&quot;T&quot;,&quot;P&quot;)) ## [1] &quot;P&quot; &quot;R&quot; &quot;X&quot; 実際にモデルからデータを生成して確認する。 たしかに、\\(T\\)と\\(S\\)以外は係数がほぼ0になる。 d_prac2 &lt;- simulateSEM(dagified_prac2, # パス係数を0.7に設定する b.lower = 0.7, b.upper = 0.7, N = 5000) lm(Y ~ X + R + S + T + P, data = d_prac2) %&gt;% model_parameters() %&gt;% print_md() Parameter Coefficient SE 95% CI t(4994) p (Intercept) -0.01 0.01 (-0.04, 0.01) -1.15 0.249 X -0.01 0.02 (-0.05, 0.02) -0.76 0.449 R -0.02 0.02 (-0.06, 0.03) -0.79 0.430 S -0.44 0.02 (-0.48, -0.39) -19.75 &lt; .001 T 0.68 0.02 (0.64, 0.72) 31.17 &lt; .001 P -6.91e-03 0.02 (-0.04, 0.03) -0.39 0.698 以下のダイアグラムについて、隣接しないノード全ての組について、その2つをd分離する変数の集合を答えよ(最小限必要な変数のみでよい)。 Figure 24: 練習問題5の因果ダイアグラム A. 以下の通り \\(X\\)と\\(Y\\): \\(\\{ W, Z3, Z1 \\},\\{ W, Z3, Z2 \\}\\) ▶ \\(X\\)と\\(Y\\)の間の道をブロックするため、\\(W\\)\\(とZ3\\)は必ず入れる必要あり。しかし\\(Z3\\)(= 合流点)を入れると\\(X \\leftarrow Z1 \\rightarrow Z3 \\leftarrow Z2 \\rightarrow Y\\)がブロックされなくなるため、加えて\\(Z1\\)または\\(Z2\\)も条件づける必要がある。 \\(Y\\)と\\(Z1\\): \\(\\{ Z3, Z2, X \\}, \\{ Z3, Z2, W \\}\\) ▶ \\(Z1 \\rightarrow Z3 \\rightarrow T\\)と\\(Z1 \\rightarrow X \\rightarrow W \\rightarrow Y\\)をブロックするため\\(Z3\\)と\\(X\\)または\\(W\\)は必ず条件づける必要あり。しかし\\(Z\\)を条件づけると\\(Z1 \\rightarrow Z3 \\leftarrow Z2 \\rightarrow Y\\)がブロックされなくなるため、\\(Z2\\)も条件づける必要がある。 \\(X\\)と\\(Z2\\): \\(\\{ Z1, Z3 \\}\\) \\(W\\)と\\(Z2\\): \\(\\{ X \\}\\), \\(\\{ Z3, Z1 \\}\\) \\(W\\)と\\(Z1\\): \\(\\{ X \\}\\) \\(W\\)と\\(Z3\\): \\(\\{ X \\}\\) 以下でも確かめられる。 #impliedConditionalIndependencies(dagified_prac3) 図24のモデルで\\(Z3\\)の値から\\(Z2\\)の値を予測する。\\(W\\)の値も使った方がよりよい予測になるか？ 一般に、\\(Z2\\)とd分離されていない(= 独立でない)限りは、どの変数を入れても予測は向上する。しかし、\\(W\\)は\\(Z3\\)で条件づけたとき\\(Z2\\)とd分離されるため、\\(W\\)を入れても予測は良くならないはずである。 これは以下のシミュレーションでも確かめられる。 d_prac3 &lt;- simulateSEM(dagified_prac3, # パス係数を0.4に設定する b.lower = 0.4, b.upper = 0.4, N = 10000) ## Z3のみ m_without_W &lt;- lm(Z2 ~ Z3, data = d_prac3) ## Z3 + W m_with_W &lt;- lm(Z2 ~ Z3 + W, data = d_prac3) ## Z3 + Y m_with_Y &lt;- lm(Z2 ~ Z3 + Y, data = d_prac3) 線形モデルの決定係数\\(R^2\\)を計算すると、\\(W\\)を入れても入れなくてもほとんど変わらないことが分かる。 一方、\\(Z3\\)とd連結している(従属な)\\(Y\\)を入れると予測は向上する。 ## 決定係数を比較 compare_performance(m_without_W,m_with_W, m_with_Y) %&gt;% data.frame() %&gt;% dplyr::select(1,7,8) %&gt;% print_md() Name R2 R2_adjusted m_without_W 0.16 0.16 m_with_W 0.16 0.16 m_with_Y 0.34 0.34 3.3 モデル検定と因果探索 実際の分析では、モデルから想定される条件付き独立が実際のデータでも見られるかによって、因果モデルが正しいものかを検証していく。 たとえば、図24では\\(W\\)と\\(Z_{1}\\)は\\(X\\)によりd分離されている。よって、もしこの因果モデルが正しいとすれば、以下の式で回帰分析を行ったときに、係数\\(R_1\\)は0になるはずである。 \\[ w = r_{X}x + r_{1}Z_{1} \\] もし\\(r_1\\)が0でないならば、因果モデルは間違っていることになる。また、真のモデルでは\\(W\\)と\\(Z_1\\)の間に\\(X\\)ではd分離されていない道があるはずだということになる。 このように、モデルにある全てのd分離の条件がデータの条件付き独立と一致するかを検討することで、モデルの検証を行える。 d分離性を利用したモデルの検証には以下の利点がある。 変数の関係を表す関数がどのような形でもグラフの構造の実から検証可能(ノンパラメトリック) 局所的なモデルの修正を行える なお、最終的には1つではなく、複数のモデルまでしか絞り込めないのことの方が多い。これは、データにある独立性/従属性と矛盾しないような因果モデルは複数存在する場合が多いからである。このようなモデルはmarcov equivalentであるという。 例えば、以下のグラフで表されるモデルは全てmarcov equivalentである。 ggdag_equivalent_dags()を用いて求められる。 dagify(X ~ Z1, Z2 ~ Z1, Y ~ Z2 + W + X, W ~ X ) -&gt; dagified_prac4 ggdag_equivalent_dags(dagified_prac4,node_size =9, text_size = 3)+ theme_dag() Figure 25: Marcov equivalentなモデルの例 練習問題 図24のモデルで、もしいずれかの係数が0でないときにモデルが誤りになる\\(Y\\)の回帰式を１つ書け たとえば、図24のモデルで\\(X\\)と\\(Y\\)は\\(Z_2,Z_3,W\\)によってd分離される。よって、以下の回帰式で\\(X\\)の係数が0でなければモデルは誤りになる。 \\[ Y = a + bX + cZ_1 + dz_3 + eW \\] 実際、モデルから生成したデータを用いて分析すると\\(X\\)の係数はほぼ0になる。 lm(Y ~ X + Z2 + Z3 + W, data = d_prac3) %&gt;% model_parameters() %&gt;% print_md() Parameter Coefficient SE 95% CI t(9995) p (Intercept) -8.72e-04 5.49e-03 (-0.01, 9.88e-03) -0.16 0.874 X 4.11e-03 7.07e-03 (-9.76e-03, 0.02) 0.58 0.561 Z2 0.40 6.06e-03 (0.39, 0.41) 66.10 &lt; .001 Z3 0.39 7.17e-03 (0.38, 0.41) 54.79 &lt; .001 W 0.40 6.01e-03 (0.39, 0.41) 66.42 &lt; .001 図24のモデルで、\\(X\\)が観測されていない場合に、もしいずれかの係数が0でないときにモデルが誤りになる\\(Z_3\\)の回帰式を１つ書け \\(X\\)が未観測のとき、条件付き独立になるのは以下の場合である。 \\(Z_3\\)と独立な変数はないため、係数が0になるような変数はない。 ## xが未観測であることにする latents(dagified_prac3) &lt;- &quot;X&quot; impliedConditionalIndependencies(dagified_prac3) ## W _||_ Z2 | Z1, Z3 ## Y _||_ Z1 | W, Z2, Z3 ## Z1 _||_ Z2 図24のモデルで問1のような回帰式がいくつあればモデルを完全に検証したことになるか。 このような回帰式の集合はbasis setと呼ばれ、以下のように求められる。 最後の2つは同じ2変数についてのものなので、4つの回帰式を検証すればよい。 ## Xが未観測という情報を消す latents(dagified_prac3) &lt;- c() impliedConditionalIndependencies(dagified_prac3, type = &quot;basis.set&quot;) ## W _||_ Z1, Z2, Z3 | X ## X _||_ Z2 | Z1, Z3 ## Y _||_ X, Z1 | W, Z2, Z3 ## Z1 _||_ Z2 ## Z2 _||_ Z1 例えば、一行目は以下の回帰式で検証できる。 \\[ W = a + bX + cZ_1 + dZ_2 + eZ_3 \\] 実際、モデルから生成したデータを用いて分析すると\\(Z_1, Z_2, Z_3\\)の係数はほぼ0になる。 lm(W ~ X + Z1 + Z2 + Z3, data = d_prac3) %&gt;% model_parameters() %&gt;% print_md() Parameter Coefficient SE 95% CI t(9995) p (Intercept) 7.74e-04 9.13e-03 (-0.02, 0.02) 0.08 0.932 X 0.38 0.01 (0.36, 0.41) 31.18 &lt; .001 Z1 5.47e-03 0.01 (-0.02, 0.03) 0.48 0.629 Z2 0.02 0.01 (-1.08e-03, 0.04) 1.86 0.064 Z3 -7.11e-03 0.01 (-0.03, 0.02) -0.59 0.558 "],["介入効果の推定.html", "4. 介入効果の推定 4.1 介入とは 4.2 調整 4.3 バックドア基準", " 4. 介入効果の推定 ここでは、いよいよ相関関係と因果関係をきちんと見分け、原因を変化させたときに結果に与える効果(因果効果・介入効果)の大きさを推定するための方法を学ぶ。 これまで見てきたように、変数間に相関関係があるからと言って、因果関係があるとは限らない場合が多々ある。よって、相関関係から予測される効果が実際の介入効果(因果効果)とズレることがよく起こる。 例えば、あなたは河川中の汚染物質量が底生昆虫の種数に与える影響を知るため、データを収集したとする。その結果、図26のようなデータが得られた(\\(X\\): 河川中の汚染物質の量, \\(Y\\): 底生昆虫の種数)。このデータだけをもとに、「底生昆虫の種数を増やすためには、河川中の汚染物質を減らすべきだ」と結論付けることはできるだろうか？ 答えはノーである。あくまでもこのデータから言えるのは、「\\(X\\)が小さいほど\\(Y\\)は大きい」ということだけであり、これは相関関係の話である。あなたが本当に知りたいのは「\\(X\\)を小さくしたときに、\\(Y\\)が大きくなる**」といえるかである。 ## `geom_smooth()` using formula &#39;y ~ x&#39; Figure 26: 河川中の汚染物質量と底生昆虫の種数の関係 例えば、各データが川の上流域/下流域のいずれで収集されたかも記録し、図27のような結果が得られたとする。このグラフから、データを上流/下流で収集するかが\\(X\\)と\\(Y\\)の両方に独立に影響したことで、\\(X\\)と\\(Y\\)の相関が生じた可能性が示唆される(交絡要因の影響)。このように、\\(X\\)と\\(Y\\)の相関が\\(X\\)と関係ない要因で生じているなら、\\(X\\)を変化させても\\(Y\\)は変化しないだろう。 ## `geom_smooth()` using formula &#39;y ~ x&#39; Figure 27: データ収集場所の情報も含めた河川中の汚染物質量と底生昆虫の種数の関係 図28のように、\\(Y\\)はデータ収集場所の影響もうけるが、それに加えて\\(X\\)の影響も部分的に受けているということもあるかもしれない(上流域/下流域それぞれでも\\(X\\)と\\(Y\\)に相関がある)。その場合、\\(X\\)を変化させれば\\(Y\\)も部分的に変化する。 ## `geom_smooth()` using formula &#39;y ~ x&#39; Figure 28: データ収集場所の情報も含めた河川中の汚染物質量と底生昆虫の種数の関係2 このように、\\(X\\)の介入効果を推定するためには、\\(Y\\)の値がどのような過程で得られるのかに大きく依存するのである。 介入効果を推定するために良く用いられる方法は、ランダム化比較試験(RCT)である。この方法では、応答(反応)変数(\\(Y\\))に影響を与える因子は、1つ(\\(X\\))を除いて固定されるか、ランダム化される。このようなとき、\\(Y\\)の変化は\\(X\\)によってのみ生じたといえるので、\\(X\\)の介入効果を正確に推定できる。 しかし、実際の研究ではRCTを行うことは不可能であることが多い(金銭的・時間的・倫理的・方法論的問題などなど…)。そのような場合、研究者は代わりにこうした操作を行わない観察研究を行うことになるが、近年の統計学の発展により、観察研究であっても適切に分析を行えば介入効果を推定できることが分かってきた。以下では、前章までに学んだことをもとに、どうすれば観察研究でも介入効果を正確に推定できるのかを学んでいく。 4.1 介入とは モデルにおいてある変数に「介入する」とは、その変数をある値に固定することを意味する(\\(\\neq\\)条件付けする)。よって、しばしば他の変数の値も変化する。一方で、値を固定するので、他の変数からの影響はなくなる。 グラフでは、\\(X\\)に介入するということは、\\(X\\)に向かう辺が全て取り除かれることを表す(図29のAからBに変化するように)。このことからも、\\(X\\)で条件するときとは変数間の関係が全く違くなることが分かる。\\(X\\)にある変数に介入する際の手順は、因果グラフの構造により異なる。 ひとことメモ \\(X\\)以外をランダム化することも、\\(X\\)へ向かう辺をすべて取り除くことに相当する。 Figure 29: Xに介入したときのグラフの変化 条件付き確率(\\(P(Y = y|X = x)\\))と区別するため、\\(X\\)をある値\\(x\\)に固定(= \\(X\\)に介入)したときに\\(Y = y\\)になる確率は、以下のように書く。 \\(do\\)表記と因果ダイアグラムを用いることで、グラフが現実を正確に表現していれば、観察データのみから介入効果を推定することができる。 \\[ P(Y = y|do(X = x)) \\] 4.2 調整 4.2.1 調整と調整化公式 それでは、\\(P(Y = y|do(X = x))\\)はどのように求めたらよいだろうか。 図30で、\\(Z\\)は性別、\\(X\\)は薬の投与の有無(0/1)、\\(Y\\)は回復の有無(0/1)を表すとする。 Figure 30: 薬の効果を表す因果ダイアグラム 患者全員に薬を投与する(\\(do(X = 1\\)))という介入と、誰にも薬を投与しないという介入(\\(do(X = 0\\))との比較を考える。このとき、その差は因果効果差または平均因果効果(ACE: average causal effect)と呼ばれ、以下の式で表せる。\\(X\\)と\\(Y\\)が複数の値をとる場合は、すべての組み合わせついて効果を算出する。 \\[ P(Y = 1|do(X = 1)) - P(Y =1| do(X=0)) \\] 因果効果\\(P(Y = y|do(X = x))\\)は、介入して\\(X\\)への辺を取り除いたモデル(図31)における条件付確率\\(P_m(Y=y|X=x)\\)に等しい1。 Figure 31: 介入後の因果ダイアグラム また、介入前と介入後のグラフにおける確率について、以下の2点が成り立つ。 \\(Z\\)を決める過程は\\(Z\\)から\\(X\\)への矢印がなくなっても変わらないので、周辺確率\\(P(Z = z)\\)は介入後も変化しない(\\(P(Z=z) = P_m(Z=z)\\))。 \\(Y\\)が\\(X\\)と\\(Z\\)によって決まる過程(つまり\\(Y = f(x,y,u_y)\\))は\\(X\\)への介入によって変わるわけではない。よって、条件付き確率\\(P(Y=y|X=x,Z=z) = P_m(Y=y|X=x,Z=z)\\)である。 加えて、介入後のグラフで\\(X\\)と\\(Z\\)はd分離されて独立なので、\\(P_m(Z=z|X=x) = P_m(Z=z)\\)も成り立つ(3)。 以上より、因果効果\\(P(Y=y|do(X=x))\\)は以下のように変形できる。 \\[ \\begin{aligned} &amp;P(Y=y|do(X=x))\\\\ &amp;= P_m(Y=y|X=x)\\\\ &amp;= \\sum_{z}P_m(Y=y|X=x,Z=z)P_m(Z=z|X=x) (全確率の公式より)\\\\ &amp;= \\sum_{Z}P_m(Y=y|X=x,Z=z)P_m(Z=z) (1より)\\\\ &amp;= \\sum_{z}P(Y=y|X=x,Z=z)P(Z=z) (2と3より) \\end{aligned} \\] この式により、因果効果を介入前のグラフのデータから計算できるようになる。 この式は調整化公式と呼ばれ、ある\\(Z\\)の値について\\(X\\)と\\(Y\\)の関係を計算し、それを\\(Z\\)について平均していることが分かる。このような処理を「\\(Z\\)による調整」または「\\(Z\\)についてのコントロール」と呼ぶ。 調整化公式の使用例: 図30のグラフについて、以下のデータ(表1)が得られているとする。 Table 1: 薬の投与に関する結果 薬投与 薬投与なし 男性 81/87が回復(93%) 234/270が回復(87%) 女性 192/263が回復(73%) 55/80が回復(69%) 全体 273/350が回復(78%) 289/350が回復(83%) このとき、平均因果効果(ACE)は以下のように求められる。なお、\\(X=1\\)は薬が投与されたこと、\\(Z=1\\)は患者が男であること、\\(Y=1\\)は患者が回復したことを表す。 ACEは正の値なので、薬の効果があったことを示す。 \\[ \\begin{aligned} &amp;P(Y = 1| do(X = 1))\\\\ &amp;= P(Y=1|X=1,Z=1)P(Z=1) + P(Y=1|X=1,Z=0)P(Z=0) \\\\ &amp;= 0.93 \\times \\frac{87+270}{700} + 0.73 \\times \\frac{263+80}{700}\\\\ &amp;= 0.832\\\\ \\end{aligned} \\] \\[ \\begin{aligned} &amp;P(Y = 1| do(X = 0))\\\\ &amp;= P(Y=1|X=0,Z=1)P(Z=1) + P(Y=1|X=0,Z=0)P(Z=0) \\\\ &amp;= 0.87 \\times \\frac{87+270}{700} + 0.69 \\times \\frac{263+80}{700}\\\\ &amp;= 0.7818\\\\ \\\\ &amp;\\therefore ACE = P(Y = 1| do(X = 1)) - P(Y = 1| do(X = 0))\\\\ &amp;= 0.832 - 0.7818 = 0.0502\\\\ \\end{aligned} \\] 4.2.2 何を調整すべきか 注意すべき点は、モデルの因果構造によって、調整すべき変数の集合\\(Z\\)が異なる点である。 例えば、因果ダイアグラムが図32のような事例を考える(\\(X\\): 薬の投与, \\(Y\\): 回復, \\(Z\\): 血圧)。 Figure 32: 薬の効果を表す因果ダイアグラム このモデルについて、因果効果\\(P(Y = 1| do(X = 1))\\)を求めたいとする。このとき、\\(Z\\)で調整すべきだろうか？ \\(X\\)への介入とは、\\(X\\)に向かう辺をすべて取り除くことであった。よって、もしこの因果ダイアグラムが正しいのであれば、\\(Z\\)で調整する必要はなく、以下の等式が成り立つ。 \\[ P(Y=1|do(X=1)) = P(Y=1|X=1) \\] 4.3 バックドア基準 それでは、どの変数を変数の集合\\(Z\\)に含めて調整すれば因果効果を適切に吸い愛知できるだろうか。 その基準として最も重要なものがバックドア基準である。 介入前と介入後のモデルにおける確立を区別するため、介入後のモデルの確立にはmを添え字として付す。↩︎ "],["動作環境.html", "動作環境", " 動作環境 sessionInfo() ## R version 4.2.0 (2022-04-22 ucrt) ## Platform: x86_64-w64-mingw32/x64 (64-bit) ## Running under: Windows 10 x64 (build 19045) ## ## Matrix products: default ## ## locale: ## [1] LC_COLLATE=Japanese_Japan.utf8 LC_CTYPE=Japanese_Japan.utf8 ## [3] LC_MONETARY=Japanese_Japan.utf8 LC_NUMERIC=C ## [5] LC_TIME=Japanese_Japan.utf8 ## ## attached base packages: ## [1] stats graphics grDevices utils datasets methods base ## ## other attached packages: ## [1] ggsci_2.9 ppcor_1.1 MASS_7.3-56 GGally_2.1.2 ## [5] report_0.5.1 see_0.7.2 correlation_0.8.2 modelbased_0.8.5 ## [9] effectsize_0.7.0.5 parameters_0.18.2 performance_0.9.2 bayestestR_0.12.1 ## [13] datawizard_0.5.1 insight_0.18.2 easystats_0.5.2 patchwork_1.1.1 ## [17] ggdag_0.2.4 dagitty_0.3-1 forcats_0.5.1 stringr_1.4.0 ## [21] dplyr_1.0.9 purrr_0.3.4 readr_2.1.2 tidyr_1.2.0 ## [25] tibble_3.1.7 ggplot2_3.3.6 tidyverse_1.3.1 ## ## loaded via a namespace (and not attached): ## [1] TH.data_1.1-1 colorspace_2.0-3 ellipsis_0.3.2 estimability_1.3 ## [5] fs_1.5.2 rstudioapi_0.13 farver_2.1.0 graphlayouts_0.8.0 ## [9] ggrepel_0.9.1 fansi_1.0.3 mvtnorm_1.1-3 lubridate_1.8.0 ## [13] xml2_1.3.3 codetools_0.2-18 splines_4.2.0 knitr_1.39 ## [17] polyclip_1.10-0 jsonlite_1.8.0 broom_0.8.0 dbplyr_2.1.1 ## [21] ggforce_0.3.3 compiler_4.2.0 httr_1.4.3 emmeans_1.7.4-1 ## [25] backports_1.4.1 assertthat_0.2.1 Matrix_1.4-1 fastmap_1.1.0 ## [29] cli_3.3.0 tweenr_1.0.2 htmltools_0.5.2 tools_4.2.0 ## [33] igraph_1.3.1 coda_0.19-4 gtable_0.3.0 glue_1.6.2 ## [37] V8_4.2.0 Rcpp_1.0.8.3 cellranger_1.1.0 jquerylib_0.1.4 ## [41] vctrs_0.4.1 nlme_3.1-157 ggraph_2.0.5 xfun_0.31 ## [45] rvest_1.0.2 lifecycle_1.0.1 zoo_1.8-10 scales_1.2.0 ## [49] tidygraph_1.2.1 hms_1.1.1 sandwich_3.0-1 RColorBrewer_1.1-3 ## [53] yaml_2.3.5 curl_4.3.2 gridExtra_2.3 sass_0.4.1 ## [57] reshape_0.8.9 stringi_1.7.6 highr_0.9 boot_1.3-28 ## [61] rlang_1.0.2 pkgconfig_2.0.3 evaluate_0.15 lattice_0.20-45 ## [65] labeling_0.4.2 tidyselect_1.1.2 plyr_1.8.7 magrittr_2.0.3 ## [69] bookdown_0.29 R6_2.5.1 generics_0.1.2 multcomp_1.4-19 ## [73] DBI_1.1.2 mgcv_1.8-40 pillar_1.7.0 haven_2.5.0 ## [77] withr_2.5.0 survival_3.3-1 modelr_0.1.8 crayon_1.5.1 ## [81] utf8_1.2.2 tzdb_0.3.0 rmarkdown_2.14 viridis_0.6.2 ## [85] grid_4.2.0 readxl_1.4.0 reprex_2.0.1 digest_0.6.29 ## [89] xtable_1.8-4 munsell_0.5.0 viridisLite_0.4.0 bslib_0.3.1 "],["404.html", "Page not found", " Page not found The page you requested cannot be found (perhaps it was moved or renamed). You may want to try searching to find the page's new location, or use the table of contents to find the page you are looking for. "]]
