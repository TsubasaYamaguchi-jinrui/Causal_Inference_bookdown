[["index.html", "Causal Inference Using R 本稿の目的", " Causal Inference Using R Tsubasa Yamaguchi 2023-04-03 本稿の目的 本稿では、統計的因果推論の理論とRでの実装についてまとめる。統計的因果推論には大きく分けて潜在的結果変数の枠組みを用いるRubin流(星野 2009; 高橋 2022)と構造的因果モデル(SCM: Structual Causal Model)と因果ダイアグラム(もしくはグラフィカルモデル)を用いるPearl流に分けられる。本稿では、主に後者に焦点を当てて解説を行う。 参考にした書籍やウェブサイトは、以下のものである。 なお、本稿の作成に使用したファイルとRのコードは全て筆者のGithubで閲覧できる。 Causal inference in statistics: A primer (邦訳「入門統計的因果推論」)(Pearl et al. 2016) \\(\\rightarrow\\) 本稿のベース The book of why: the new science of cause and effect. (邦訳「因果推論の科学」)(Pearl and Mackenzie 2018) \\(\\rightarrow\\) 一般向け書籍。数式を用いない解説や事例が豊富。因果推論の科学ができるまでの歴史についても学べる。 岩波データサイエンス vol. 3 因果推論ー実世界のデータから因果を読む(岩波データサイエンス刊行委員会 2016) \\(\\rightarrow\\) バックドア基準をはじめ因果推論のトピックに関する短くわかりやすい解説 統計的因果推論―回帰分析の新しい枠組み― (宮川 2004) Take a Risk: 林岳彦の研究メモ ウェブサイト References "],["パッケージの読み込み.html", "0 パッケージの読み込み", " 0 パッケージの読み込み 因果ダイアグラムの分析には主にdagittyパッケージ(Textor et al. 2016)を、描画にはdagittyをベースに作られたggdagパッケージ(Barrett 2018)を用いる。 それぞれの関数の使い方は以下のサイトを参照。 dagitty ggdag library(tidyverse) library(dagitty) library(ggdag) library(patchwork) library(easystats) library(GGally) library(ppcor) library(ggsci) library(knitr) なお、本稿はRの基本操作とtidyverseパッケージによるデータハンドリングができることを前提としている。 tidyverseパッケージを用いたデータ処理については、以下を参照。 R for Data Science (Wickham and Grolemund 2016) 電子書籍, 日本語 R Graphics Coocbook 2nd Edition (Chang 2018) 電子書籍, 日本語 RユーザのためのRstudio[実践]入門~tidyverseによるモダンな分析フローの世界 改訂2版 (松村 et al. 2021) 出版社サイト References "],["なぜ統計的因果推論が必要か.html", "1 なぜ統計的因果推論が必要か", " 1 なぜ統計的因果推論が必要か 私たちが研究を行う上で立てるリサーチクエスチョンの多くは、「ニホンザルの群れの凝集性はオスの攻撃に影響を受けるのか」、「食物状況はオスの性行動に影響しているか」というようなものである。これらの問いは、2つ(あるいはそれ以上)の変数間の単なる相関関係(「\\(X\\)が小さい/大きいほど、\\(Y\\)も小さい/大きい」)ではなく、因果関係(「\\(X\\)を小さく/大きくすると、\\(Y\\)も小さく/大きくなる」)に関する問いである。すなわち、私たちの研究のゴールの多くは、データから変数間の因果関係を推測(= 統計的因果推論)することにあるのである。よって、統計的因果推論の手法を学ぶことは、私たちの研究の根本にかかわる重要なことである。 統計的因果推論についての知識がなければ、実際に得られたデータから因果関係を推測することは難しい。特に研究者が変数への操作や介入を行えない観察研究では、複数の要因が複雑に影響し合っていることが珍しくないため、殊更に困難である。そのような状況では、変数間でみられる相関関係が実際の因果関係と一致しないことが良く起こるからである。 以下の例を考えてみよう。 ニホンザルのコドモにおいて、ある期間に食べた1日当たりの平均食物摂取量(乾燥重量で\\(X\\)g)がその期間における遊び時間割合(\\(Y\\)%)に影響しているかを調べたいとする。\\(X\\)と\\(Y\\)、そして年齢(\\(Z\\))の間に図1.1の間のような因果関係があるとする(もちろん架空の関係である)。なお、丸は各変数を、矢印は因果関係を表す(詳細は2.3節を参照)。 図1.1: X, Y, Zの間の因果関係 このような関係の下ではどのようなデータが得られるだろうか。シミュレーションによって図1.1のような因果関係を持つデータを生成し1、\\(X\\)と\\(Y\\)の関係を散布図にしたものが、図1.2である。 この図からは「食物摂取量(\\(X\\))が多いほど、遊び時間割合(\\(Y\\))が少ない」という負の相関関係が読み取れる。この関係は、「食物摂取量(\\(X\\))が多くなると、遊び時間割合(\\(Y\\))が多くなる」という実際の因果関係(図1.1参照)とは正負が逆になってしまっている。つまり、\\(X\\)と\\(Y\\)の相関関係だけを見るだけでは、その因果関係を適切に推測できないのである。 図1.2: 平均食物摂取量(X)と遊び時間割合(Y)の関係。直線は回帰直線を表す。 なぜこのようなことが起こるのだろうか。それは、\\(X\\)と\\(Y\\)の因果関係を適切に推測するためには、その両方に影響している第3の変数\\(Z\\)(年齢)を考慮しなくてはならないからである。年齢ごとに\\(X\\)と\\(Y\\)の関係を見てみると、実際の因果関係と一致した方向の正の相関(「\\(X\\)が多いほど\\(Y\\)も多い」)が確認できるようになる。 図1.3: 年齢(Z)を考慮した平均食物摂取量(X)と遊び時間割合(Y)の関係。直線は年齢ごとの回帰直線を表す。 このように、データから適切な因果推論を行うためには、データの背後にある変数間の因果構造(= データ生成過程)を考慮しなければならない。この後見ていくように、データの因果構造によってどのような変数を考慮して分析すべきかは異なってくる。本稿では、構造的因果モデル(SCM)と因果ダイアグラムという2つのツールを用いることで、いかなる因果構造を持つデータにおいても適切に因果推論を行うための手法を学んでいく。 次章以降で学ぶ内容は以下のとおりである。 因果関係を正確に記述する方法(第2章) 因果モデルの構造をデータの特徴に関連付ける方法(第3章) モデルとデータに含まれる因果関係の組み合わせから結論を導く方法(第4~5章) なお、\\(X, Y, Z\\)は以下の確率分布に従って得られるとした。\\[\\begin{aligned}X &amp;\\sim Normal(20Z + 120, 10)\\\\Y &amp;\\sim Normal(0.2X - 10Z + 25, 5)\\end{aligned}\\] 確率分布については、2.1を、詳細はRのコードを参照。↩︎ "],["構造的因果モデルと因果ダイアグラムの基礎.html", "2 構造的因果モデルと因果ダイアグラムの基礎 2.1 確率と統計の基礎 2.2 構造的因果モデル(SCM) 2.3 因果ダイアグラムの概要 2.4 因果ダイアグラムの描き方 2.5 因果ダイアグラムの基礎 2.6 独立と従属", " 2 構造的因果モデルと因果ダイアグラムの基礎 2.1 確率と統計の基礎 まずは、確率と統計についての基礎知識の復習から行う。 変数: 複数の値を取りうる特性(例: 被験者の年齢、性別、採食時間割合、…)。以下、大文字のアルファベットで表す。 変数\\(X\\)が値\\(x\\)になる確率を\\(P(X=x)\\)と表す。 例: 性別を変数\\(X\\)とするとき、オスである確率は\\(P(X = オス)\\)と書ける。 同時確率: \\(X = x\\) かつ \\(Y = y\\)である確率を、\\(P(X=x,Y=y)\\)と表す。 条件付き確率: \\(X =x\\)であるときに\\(Y=y\\)となる確率を\\(P(Y=y|X=x)\\)と書き、このような確率を条件付き確率という。なお、\\(P(X=x, Y=y) = P(Y=y|X=x)\\times P(X=x)\\)と表せる。 例: オスの採食時間割合(\\(Y\\))が20%より多い確率は、\\(P(Y &gt; 20|X = オス)\\)。 確率分布: ある変数\\(X\\)がとりうる全ての値について、それが起きる確率の分布を示したものである。なお、変数\\(X\\)がある確率分布\\(P(X=x)\\)に従うとき、\\(X \\sim P(x)\\)と書く。 確率分布の例 離散変数の場合 (例. ある湖で1時間にとれる魚の数\\(X\\)の確率分布2) 図2.1: 離散変数の確率分布 連続変数の場合 (例. 東京の8月の気温\\(X\\)の確率分布3) 図2.2: 連続変数の確率分布 2.2 構造的因果モデル(SCM) 変数間の因果関係を記述するためには、データセットにある変数間の因果関係についての仮定を正式に記述する必要がある。そのために、構造的因果モデル(SCM: Structural Causal Model)を導入する。SCMは、以下の3つによって記述される。 \\(V\\): その変動理由がモデル内で記述される変数(内生変数)の集合 \\(U\\): その変動理由がモデル内で記述されない変数(外生変数)の集合 \\(F\\): モデル内の他の変数によって内生変数の値を決定する関数の集合 外生変数は他の変数によって記述できない(=他の変数の子孫ではない)。 一方で、内生変数は少なくとも1つの外生変数を含む関数を用いて記述される(=少なくとも1つの外生変数の子孫である)。すなわち、すべての外生変数の値が分かれば、関数\\(F\\)により全ての内生変数の値が正確に決定される。 例: 教育レベル(\\(X\\))と職務経験(\\(Y\\))、給料(\\(Z\\))の関係 以下の関数\\(f_Z\\)に基づき、\\(Z\\)が\\(X\\)と\\(Y\\)によって決定されるとする。 \\(U = \\lbrace X, Y \\rbrace, V = \\lbrace Z \\rbrace, F = \\lbrace f_Z \\rbrace\\) \\[ \\begin{aligned} f_Z: Z &amp;= 2X + 3Y \\end{aligned} \\] 因果の定義(Pearl et al. 2016) SCM内で\\(Y\\)の値を決定する関数に\\(X\\)が使われるとき、\\(X\\)は\\(Y\\)の直接原因であるという。\\(X\\)が\\(Y\\)の直接原因であるか、\\(Y\\)の原因の直接原因であるとき、\\(X\\)は\\(Y\\)の原因であるという。上の例では、\\(X\\)と\\(Y\\)は\\(Z\\)の直接原因である。 ひとことメモ 因果関係の定義には様々な流儀があり、ここではPearl et al. (2016)の定義を紹介した。 前述の定義とほとんど同じであるが、例えば林・黒木(2016)は以下のように定義している。 「要因\\(X\\)を人為的に変化させた(介入した)とき、要因\\(Y\\)も変化する」とき「要因\\(X \\rightarrow Y\\)の因果関係がある」と呼ぶ 2.3 因果ダイアグラムの概要 因果ダイアグラムとは、図1.1のように丸(記号は何でもよいが)と矢印を用いて変数間の因果構造を表したものである。矢印は因果関係を表し、それぞれのSCMには対応する因果ダイアグラムが必ず存在する。因果ダイアグラムを活用することで、定量的なデータに依ることなくモデルの中に存在する変数の関係を表現することができるので、因果推論を行う上で非常に重要なツールである。 先ほどの例を因果ダイアグラムで表すと以下のようになる。 図2.3: 因果ダイアグラムの例 2.4 因果ダイアグラムの描き方 ここでは、Rでの因果ダイアグラムの描き方を解説する。 まずはノード(点)の名前と位置(x,y座標)を記したデータフレーム(あるいはtibble)を作成する。 dag1 &lt;- tibble(name = c(&quot;A&quot;,&quot;B&quot;,&quot;C&quot;,&quot;D&quot;), x = c(1, 2, 3, 2), y = c(2, 2, 2, 1)) その後、dagify()でノード間の関係を記述する。 y ~ xはy &lt;- xを表す。 x1 ~~ x2は x1 &lt;-&gt; x2を表す。 dagified_dag1 &lt;- dagify(A ~ B, C ~ B, D ~ A + C, ## 暴露変数の指定ができる exposure = &quot;C&quot;, ## 結果変数の指定ができる outcome = &quot;D&quot;, coords = dag1) グラフの描画に必要な情報が書き込まれるよう。 dagified_dag1 ## dag { ## A [pos=&quot;1.000,2.000&quot;] ## B [pos=&quot;2.000,2.000&quot;] ## C [exposure,pos=&quot;3.000,2.000&quot;] ## D [outcome,pos=&quot;2.000,1.000&quot;] ## A -&gt; D ## B -&gt; A ## B -&gt; C ## C -&gt; D ## } tidy_dagitty()でデータフレームの形で出力もできる。 tidy_dagitty(dagified_dag1) ## # A DAG with 4 nodes and 4 edges ## # ## # Exposure: C ## # Outcome: D ## # ## # A tibble: 5 × 8 ## name x y direction to xend yend circular ## &lt;chr&gt; &lt;int&gt; &lt;int&gt; &lt;fct&gt; &lt;chr&gt; &lt;int&gt; &lt;int&gt; &lt;lgl&gt; ## 1 A 1 2 -&gt; D 2 1 FALSE ## 2 B 2 2 -&gt; A 1 2 FALSE ## 3 B 2 2 -&gt; C 3 2 FALSE ## 4 C 3 2 -&gt; D 2 1 FALSE ## 5 D 2 1 &lt;NA&gt; &lt;NA&gt; NA NA FALSE 最後に、ggplot()を用いてダイアグラムを描画する。 ggdagパッケージに含まれる関数も使用する。 ggplot(dagified_dag1, aes(x = x, y=y, xend = xend, yend = yend))+ ## ノード、文字、エッジの設定。Dのみ色を変える geom_dag_point(aes(color = name == &quot;D&quot;), alpha = 1/2, size = 10.5, show.legend = F)+ geom_dag_text(color = &quot;black&quot;)+ geom_dag_edges()+ scale_color_manual(values = c(&quot;steelblue&quot;, &quot;orange&quot;))+ ## 座標を消す scale_x_continuous(NULL, breaks = NULL, expand = c(.1, .1)) + scale_y_continuous(NULL, breaks = NULL, expand = c(.1, .1)) + theme_minimal() + theme(panel.grid = element_blank()) 図2.4: 作成した因果ダイアグラム 特にこだわりがなければ、ggdag()で容易に描ける。 theme_dag()で最小限のテーマ(目盛や背景を削除)にしてくれる。 ggdag(dagified_dag1, node_size =10, text_size = 3)+ theme_dag() 図2.5: ggdag()で描いた因果ダイアグラム 2.5 因果ダイアグラムの基礎 有向辺(方向のあるエッジ)の始点を親、終点を子と呼ぶ。 図2.6: ノードの親子 また、2つ以上のノードがあり、2つのノードをつなぐ道を矢印を伝ってたどることができるとき、つまり2つの有向辺が共に入ってくるノードや、2つの有向辺が共に出ていくノードがない場合(下図のようなとき)、これを有向道と呼ぶ。 有向道上の最初のノードは、道上のすべてのノードの祖先である(下図で、AはCの祖先、CはAの子孫(=孫)である)。 図2.7: ノードの親・子・孫 Rでは、dagittyパッケージでこれを求められる。 図2.4の因果ダイアグラムを用いて求めてみる。 親 ## 親 parents(dagified_dag1,&quot;D&quot;) ## [1] &quot;A&quot; &quot;C&quot; ## 子 children(dagified_dag1, &quot;B&quot;) ## [1] &quot;A&quot; &quot;C&quot; ## 祖先 ancestors(dagified_dag1, &quot;D&quot;) ## [1] &quot;D&quot; &quot;C&quot; &quot;B&quot; &quot;A&quot; ## 子孫 descendants(dagified_dag1, &quot;B&quot;) ## [1] &quot;B&quot; &quot;C&quot; &quot;D&quot; &quot;A&quot; また、特定の2つのノード間の有向道は以下のように求められる。 図2.4の因果ダイアグラムにおける\\(B\\)と\\(D\\)の間の有向道を調べると以下のようになる。 paths(dagified_dag1, &quot;B&quot;, &quot;D&quot;, directed = T)$path ## [1] &quot;B -&gt; A -&gt; D&quot; &quot;B -&gt; C -&gt; D&quot; なお、矢印の向きにかかわらず、2つのノードAとBがエッジ(辺)によって繋がっているとき、それをAとBをつなぐ道という。 path()でdirected = Fとすると、有向道を含む全ての道を調べられる(この例では有向道しかないが…)。 paths(dagified_dag1, &quot;B&quot;, &quot;D&quot;, directed = F)$path ## [1] &quot;B -&gt; A -&gt; D&quot; &quot;B -&gt; C -&gt; D&quot; 有向道があるノードからスタートして、それ自身に戻ってくるとき、その道とグラフは巡回的という。一方、巡回的でないグラフを非巡回的であるという。図2.8では、左が巡回的、右が非巡回的なグラフである。 図2.8: 巡回的なグラフと非巡回的なグラフの例 2.6 独立と従属 2つの変数\\(X\\)と\\(Y\\)は、以下が成り立つときにそれぞれがとりうる全ての値\\(x\\)と\\(y\\)について独立という。 \\[ P(X = x|Y = y) = P(X = x) \\] すなわち、\\(X\\)と\\(Y\\)が独立のとき、変数\\(Y\\)の値がなんであろうと、\\(P(X = x)\\)の値は変わらない(= 相関がない)。独立は記号を用いて以下のように表せる。 \\[ X \\mathop{\\perp\\!\\!\\!\\!\\perp} Y \\] また、確率変数\\(Z\\)の任意の値が与えられたときに\\(X\\)と\\(Y\\)が全ての\\(x\\)、\\(y\\)について独立のとき、\\(X\\)と\\(Y\\)は\\(Z\\)の下で条件付き独立であるといい、以下のようにあらわす。 \\[ X \\mathop{\\perp\\!\\!\\!\\!\\perp} Y|Z \\] 因果ダイアグラム上で独立または条件付き独立であるノードは、impliedConditionalIndependencies()を用いて以下のように求められる(例. 図2.4について)。 impliedConditionalIndependencies(dagified_dag1) ## A _||_ C | B ## B _||_ D | A, C なお、独立でない2変数は従属であるという。 ひとことメモ 実際の分析では、例えば以下のような場合に\\(Z\\)について条件付けしたことになる。 ある\\(Z\\)の値のデータのみを抽出して分析する 偏相関係数の計算: \\(Z\\)の影響を排除して他の2変数相関係数を算出する 回帰分析: 説明変数に\\(Z\\)を加えて回帰分析を行う References "],["因果ダイアグラムの因果推論への応用.html", "3 因果ダイアグラムの因果推論への応用 3.1 因果ダイアグラムの基本3パターン 3.2 d分離性(d-separation) 3.3 モデル検定と因果探索", " 3 因果ダイアグラムの因果推論への応用 この章では、因果ダイアグラムを因果推論へ応用する方法を学ぶ。 具体的には、以下の手順によって仮定した因果モデル(SCM)が正しいものか検証し、変数間の因果関係を探索することになる。 あるSCM(とそれに対応する因果ダイアグラム)が正しいと仮定したとき、変数間の独立/従属関係がどのようになるかを調べる(3.1, 3.2) 実際のデータにおける独立/従属関係が、仮定した因果ダイアグラムから想定される独立/従属関係と一致するか確認することで、SCMで仮定した因果関係が正しいかを検証し、必要な場合は修正する(3.3) 3.1 因果ダイアグラムの基本3パターン まず、因果ダイアグラムに現れる基本3パターンをまとめる。実際の因果ダイアグラムはより複雑だが、基本的にはどのようなダイアグラムもこの3パターンの因果構造の組み合わせで表せる。 本節ではそれぞれのパターンで、どのようなときに因果ダイアグラムに含まれる2変数が独立/従属になるかを学ぶ。これによって以下のことが可能になる。 相関(あるいは従属)\\(\\neq\\)因果になるのがどのようなときなのかを理解できるようになる 最終的に、いかなる因果ダイアグラムにおいても、変数間の独立/従属関係が分かるようになる 3.1.1 連鎖経路(chain) 3.1.1.1 概要 図3.1のように3つのノードと2つのエッジがあり、中央の変数に1つのノードが入ってきて、また別のノードがそこから出ていく構成を連鎖経路(chain)と呼ぶ。 \\(X\\)と\\(Y\\)は\\(Z\\)の原因である \\(Y\\)を\\(X \\rightarrow Z\\)の因果関係における中間変数(あるいは媒介因子)という dag4 &lt;- tibble(name = c(&quot;X&quot;,&quot;Y&quot;,&quot;Z&quot;), x = c(1.5, 2, 2.5), y = c(2.5, 2, 1.5)) dagified_chain &lt;- dagify(Y ~ X, Z ~ Y, coords = dag4) 図3.1: 連鎖経路の例 連鎖経路では以下が成り立つ。 \\(X\\)と\\(Y\\)、\\(Y\\)と\\(Z\\)、\\(X\\)と\\(Z\\)は特異な例を除けばそれぞれ従属である4 \\(X\\)と\\(Z\\)は、\\(Y\\)の下で条件付き独立 2は、\\(Y\\)で条件づけると、因果関係がある\\(X\\)と\\(Z\\)の相関が消えてしまうことを示している。 2はRでも確かめられる()。 impliedConditionalIndependencies(dagified_chain) ## X _||_ Z | Y 3.1.1.2 連鎖経路の例 2は以下のような例でも確かめられる。 \\(X\\)、\\(Y\\)、\\(Z\\)の間に以下のような関係(SCM)が成り立つとする。 ただし、\\(U_x\\)、\\(U_y\\)、\\(U_z\\)は平均0で標準偏差1の正規分布に従い、互いに独立とする(以後同様)。 \\[ \\begin{aligned} X &amp;= U_x\\\\ Y &amp;= \\frac{4}{5}X + U_y\\\\ Z &amp;= \\frac{2}{3}Y + U_z\\\\ \\end{aligned} \\] 上記のSCMは以下のようにも書き換えられる。 \\(X \\sim Normal(0,1)\\)は\\(X\\)が平均0,標準偏差1の正規分布に従うことを表す。 ただし、\\(i = 1, 2, ...,N\\)である。 \\[ \\begin{aligned} x_{i} &amp;\\sim Normal(0,1) \\\\ y_{i} &amp;\\sim Normal(\\frac{4}{5}x_{i},1) \\\\ z_{i} &amp;\\sim Normal(\\frac{2}{3}y_{i},1) \\\\ \\end{aligned} \\] 実際にデータを生成して分析してみる。 N &lt;- 10000 Ux &lt;- rnorm( N ); Uy &lt;- rnorm( N ); Uz &lt;- rnorm( N ) X &lt;- Ux Y &lt;- 4/5*X + Uy Z &lt;- 2/3*Y + Uz d &lt;- data.frame(X=X,Y=Y,Z=Z) \\(X\\)、\\(Y\\)、\\(Z\\)の関係を見ると、互いに有意に相関している(\\(X\\),\\(Y\\),\\(Z\\)は互いに従属)。 ggpairs(d) 図3.2: 連鎖経路におけるX, Y, Zの間の関係 回帰分析(\\(Z \\sim X\\))をすると、\\(X\\)と\\(Z\\)は有意に関連している(\\(X\\)と\\(Z\\)は従属)。 model_parameters(lm(Z~X,d)) %&gt;% data.frame() %&gt;% dplyr::select(1,2,3,9) %&gt;% kable(digits = 3, align = &quot;lccc&quot;) Parameter Coefficient SE p (Intercept) -0.007 0.012 0.558 X 0.520 0.012 0.000 しかし、説明変数に\\(Y\\)も加えると(=\\(Y\\)で条件づけると)、\\(X\\)の係数はほぼ0になり、因果関係がある\\(X\\)と\\(Z\\)の関連は消失してしまう。このことからも、\\(X\\)と\\(Z\\)は、\\(Y\\)の下で条件付き独立であることが分かる。 ▶ \\(Y\\)の値が分かれば、\\(Z\\)を予測するうえで\\(X\\)の値は関係なくなるから(\\(X\\)は\\(Y\\)を通してしか\\(Z\\)に影響を与えていないので) model_parameters(lm(Z~X+Y,d)) %&gt;% data.frame() %&gt;% dplyr::select(1,2,3,9) %&gt;% kable(digits = 3, align = &quot;lccc&quot;) Parameter Coefficient SE p (Intercept) -0.008 0.010 0.451 X 0.004 0.013 0.780 Y 0.655 0.010 0.000 なお、XとYの間の有向道が1つだけあり、それが連鎖経路であるとき、\\(X\\)と\\(Y\\)はその間のいずれの変数(1つでなくともよい)の下でも条件付き独立である。すなわち、下図で\\(X\\)と\\(W\\)は\\(Y\\)と\\(Z\\)いずれでの下でも条件付き独立になる。 図3.3: 連鎖経路の例2 3.1.2 分岐経路(fork) 3.1.2.1 概要 図3.4のように、2つの変数に共通の変数が影響を与えているような構成を分岐経路(fork)と呼ぶ。またこのとき、\\(X\\)を交絡因子(変数)と呼ぶ。 dag5 &lt;- tibble(name = c(&quot;X&quot;,&quot;Y&quot;,&quot;Z&quot;), x = c(2, 1, 3), y = c(2, 1, 1)) dagify(Y ~ X, Z ~ X, coords = dag5) -&gt; dagified_fork 図3.4: 分岐経路の例 分岐経路では以下が成り立つ。 \\(X\\)と\\(Y\\)、\\(X\\)と\\(Z\\)、\\(Y\\)と\\(Z\\)は特異な例を除けばそれぞれ従属 \\(Y\\)と\\(Z\\)は\\(X\\)の下で条件付き独立 1は、交絡因子によって因果関係にない\\(Y\\)と\\(Z\\)の間に相関が生じてしまうことを示している。 2は、この相関は\\(X\\)で条件づけることによって消失することを示す。 これはRでも確かめられる。 impliedConditionalIndependencies(dagified_fork) ## Y _||_ Z | X 3.1.2.2 分岐経路の例 2を直観的に確かめるため、以下の例を考える。 \\(X\\)、\\(Y\\)、\\(Z\\)の間に以下のような関係(SCM)が成り立つと、\\(X\\)、\\(Y\\)、\\(Z\\)の関係は分岐経路で表せる。 \\(X\\)(＝気温)が\\(Y\\)(= アイスクリームの売上)と\\(Z\\)(= プール来場者数)に影響 \\(Y\\)と\\(Z\\)は互いに影響しない \\[ \\begin{aligned} X &amp;= U_x\\\\ Y &amp;= \\frac{5}{2}X + U_y\\\\ Z &amp;= \\frac{2}{3}X + U_z\\\\ \\end{aligned} \\] 上記のSCMは以下のようにも書ける。 ただし、\\(i = 1,2,...N\\)。 \\[ \\begin{aligned} x_{i} &amp;\\sim Normal(0,1) \\\\ y_{i} &amp;\\sim Normal(\\frac{5}{2}x_{i},1) \\\\ z_{i} &amp;\\sim Normal(\\frac{2}{3}x_{i},1) \\\\ \\end{aligned} \\] SCMをもとに実際にデータを生成してみる。 N &lt;- 10000 Ux &lt;- rnorm( N ); Uy &lt;- rnorm( N ); Uz &lt;- rnorm( N ) X &lt;- Ux Y &lt;- 5/2*X + Uy Z &lt;- 2/3*X + Uz d &lt;- data.frame(X=X,Y=Y,Z=Z) \\(X\\)、\\(Y\\)、\\(Z\\)の関係を見ると、互いに有意に強く相関している(=\\(X\\),\\(Y\\),\\(Z\\)は互いに従属している)。 ggpairs(d) 図3.5: 分岐経路におけるX, Y, Zの間の関係 回帰分析(\\(Z \\sim Y\\))をすると、\\(Y\\)と\\(Z\\)は有意に関連している(\\(Y\\)と\\(Z\\)は従属)。 model_parameters(lm(Z~Y,d)) %&gt;% data.frame() %&gt;% dplyr::select(1,2,3,9) %&gt;% kable(digits = 3, align = &quot;lccc&quot;) Parameter Coefficient SE p (Intercept) 0.006 0.010 0.567 Y 0.228 0.004 0.000 しかし、説明変数に\\(X\\)も加えると(=\\(X\\)で条件づけると)、\\(Y\\)の係数はほぼ0になり、\\(Y\\)と\\(Z\\)の関連は消失する(=\\(Y\\)と\\(Z\\)は\\(X\\)の下で条件付き独立)。すなわち、交絡が解消された。 model_parameters(lm(Z~X+Y,d)) %&gt;% data.frame() %&gt;% dplyr::select(1,2,3,9) %&gt;% kable(digits = 3, align = &quot;lccc&quot;) Parameter Coefficient SE p (Intercept) 0.006 0.010 0.550 X 0.642 0.027 0.000 Y 0.006 0.010 0.535 3.1.3 合流点(collider) 3.1.3.1 概要 図3.6のようにあるノードに他の2つのノードからエッジが入ってきている構成を合流点(collider)と呼ぶ。 dag5 &lt;- tibble(name = c(&quot;X&quot;,&quot;Z&quot;,&quot;Y&quot;), x = c(1, 2, 3), y = c(2, 1, 2)) dagify(Z ~ X, Z ~ Y, coords = dag5) -&gt; dagified_collider 図3.6: 合流点の例 合流点では以下が成り立つ。 \\(X\\)と\\(Z\\)、\\(Y\\)と\\(Z\\)は特異な例を除けばそれぞれ従属 \\(X\\)と\\(Y\\)は独立 \\(X\\)と\\(Y\\)は\\(Z\\)の下で条件付き従属 1は自明であり、2もRで確かめられる。 impliedConditionalIndependencies(dagified_collider) ## X _||_ Y 3.1.3.2 合流点の例1 1と2は直観的に理解できるが、3が成り立つのはなぜだろうか？ 以下の例を考える。 ある大学の入学試験で以下のように合否を判定するとする 音楽試験の点数(\\(X\\))と学力試験の点数(\\(Y\\))の合計点で合否(\\(Z\\)、\\(X+Y &gt; 115\\)なら合格)を判定 \\(X\\)と\\(Y\\)には全く関連がない \\(U_X\\)と\\(U_y\\)はそれぞれ平均50、標準偏差10の正規分布に従う \\[ \\begin{aligned} X &amp;= U_x\\\\ Y &amp;= U_y\\\\ Z &amp;= \\left\\{ \\begin{array}{ll} 1(合格) &amp; (X + Y &gt; 115)\\\\ 0(不合格) &amp; (X + Y &lt; 115) \\end{array} \\right. \\end{aligned} \\] 上記のSCMは以下のように書き換えられる。 ただし、\\(i = 1,2,...N\\)。 \\[ \\begin{aligned} x_{i} &amp;\\sim Normal(50,10) \\\\ y_{i} &amp;\\sim Normal(50,10) \\\\ z &amp;= \\left\\{ \\begin{array}{ll} 1(合格) &amp; (x_{i} + y_{i} &gt; 115)\\\\ 0(不合格) &amp; (x_{i} + y_{i} &lt; 115) \\end{array} \\right. \\end{aligned} \\] 実際にこれに基づいてデータを生成して分布をみてみると、1と2が確かめられる。 N &lt;- 500 Ux &lt;- rnorm(N, mean = 50, sd = 10); Uy &lt;- rnorm(N, mean = 50, sd = 10); Uz &lt;- rnorm( N ) X &lt;- Ux Y &lt;- Uy Z &lt;- vector() for(i in 1:500){ if (X[i] + Y[i] &gt; 115){ Z[i] &lt;- &quot;1&quot; }else{ Z[i] &lt;- &quot;0&quot; } } d &lt;- data.frame(X=X,Y=Y,Z=Z) 合格者(\\(Z=1\\))の方が不合格者(\\(Z=0\\))より、\\(X\\)と\\(Y\\)がそれぞれ大きい(= \\(X\\)と\\(Z\\)、\\(Y\\)と\\(Z\\)は従属) \\(X\\)と\\(Y\\)には相関がない(= 独立)。 ggpairs(d) 図3.7: 合流点を含む経路におけるX, Y, Zの間の関係 ここで、\\(Z\\)で条件付けるとどうなるだろうか。例えば、合格者(\\(Z=1\\))のデータのみを抽出する。 青い直線は合格者のみのデータを抽出したときの回帰直線である。このとき、因果関係にない\\(X\\)と\\(Y\\)の間に相関が生じていることが分かる(= \\(X\\)と\\(Y\\)は\\(Z\\)の下で条件付き従属)。これを合流点バイアスという。 図3.8: 合流点バイアスの例 これは偏相関係数を算出することでも確かめられる。 \\(Z\\)を統制した場合の\\(X\\)と\\(Y\\)の偏相関係数を調べると、有意な相関が現れる(= \\(X\\)と\\(Y\\)は\\(Z\\)の下で条件付き従属)。 pcor.test(d$X,d$Y,d$Z %&gt;% as.numeric()) ## estimate p.value statistic n gp Method ## 1 -0.2315841 1.681337e-07 -5.307092 500 1 pearson 3.1.3.3 合流点の例2 なお、合流点だけでなく、合流点の子孫のいずれを条件付けした場合でも、独立した変数同士が従属になることがある。以下の例を考える。 交尾期において、各観察日にニホンザルの群れに訪れる群れ外オスの数(\\(Z\\))は、その日の発情メスの数(\\(X\\))と気温(\\(Y\\))によって決まるとする。また、メスがオスから攻撃される頻度(\\(W\\))は、その日に群れを訪れた群れ外オスの数(\\(Z\\))に依存するとする。 以下のSCMを考える。 \\[ \\begin{aligned} x_{i} &amp;\\sim Poisson(3.5)\\\\ y_{i} &amp;\\sim Normal(10,1.5)\\\\ z_{i} &amp;\\sim Poisson(0.8x_{i}+0.75y_{i}-2)\\\\ w &amp;\\sim Normal(0.4z_{i} + 1.2, 0.5) \\end{aligned} \\] SCMを因果ダイアグラムで表すと図3.9のようになる。 dag6 &lt;- tibble(name = c(&quot;X&quot;,&quot;Z&quot;,&quot;Y&quot;,&quot;W&quot;), x = c(1, 2, 3,2), y = c(2, 1.5, 2,1)) dagify(Z ~ X, Z ~ Y, W ~ Z, coords = dag6) -&gt; dagified_collider_b 図3.9: 合流点の例2 実際にこれに基づいてデータを生成して分布をみてみると、\\(X\\)と\\(Y\\)に有意な相関はない(=独立である)ことが確かめられる。また、\\(Z\\)と\\(W\\)はどちらも\\(X\\), \\(Y\\)と有意な相関がある(=従属)。 set.seed(191) N &lt;- 500 X &lt;- rpois(N, 3.5) Y &lt;- rnorm(N, 10, 1.5) Z &lt;- rpois(N, 0.8*X + 0.75*Y - 2) W &lt;- rnorm(N, 0.4*Z+1.2, 0.5) d &lt;- data.frame(X=X,Y=Y,Z=Z,W=W) ggpairs(d) 図3.10: 合流点の子を含む経路におけるX, Y, Z, Wの間の関係 一方、\\(Z\\)またはその子孫である\\(W\\)を統制した場合の\\(X\\)と\\(Y\\)の偏相関係数を調べると、いずれも小さいが有意な相関が現れる(=条件付き従属)。 \\(Z\\)を統制 pcor.test(d$X,d$Y,d$Z) ## estimate p.value statistic n gp Method ## 1 -0.1296674 0.003713279 -2.915352 500 1 pearson \\(W\\)を統制 pcor.test(d$X,d$Y,d$W) ## estimate p.value statistic n gp Method ## 1 -0.1068466 0.0169576 -2.395699 500 1 pearson 3.2 d分離性(d-separation) 一般的な因果モデル(ダイアグラム)は、以上で見た3つのパターンより複雑であることが多い。具体的には、多くのモデルにおいて変数間を結ぶ道は複数存在し、それぞれの道は様々な連鎖、分岐、合流点を通過している。 ここでは、このように複雑なモデルにおいても変数間の独立/従属を判断するため、前節までに学んだことをもとにd-分離(d-separation)という概念を導入する。２つのノード(変数)がd分離されるとき、それらの変数は独立であるといえる。 d分離の定義 (Pearl et al. 2016) 以下の1または2が成り立つとき、グラフ上で道\\(p\\)がノードの集合\\(Z\\)にブロックされているという。 \\(p\\)は連鎖経路\\(A \\rightarrow B \\rightarrow C\\)または分岐経路\\(A \\leftarrow B \\rightarrow C\\)を含み、中央のノードが\\(Z\\)に含まれる(= \\(B\\)について条件付けしている) \\(p\\)は合流点\\(A \\rightarrow B \\leftarrow C\\)を含み、合流点\\(B\\)とその全ての子孫が\\(Z\\)に含まれない(= \\(Z\\)とその子孫で条件付けしない) \\(Z\\)が\\(X\\)と\\(Y\\)の間の道をすべてブロックするとき、\\(Z\\)が与えられた下で\\(X\\)と\\(Y\\)はd分離しているという。 一方で、\\(X\\)と\\(Y\\)がd分離されていないとき、\\(X\\)と\\(Y\\)はd連結であるという。 例1. 合流点とその子、分岐点を持つ因果ダイアグラム dag7 &lt;- tibble(name = c(&quot;X&quot;,&quot;Z&quot;,&quot;Y&quot;,&quot;W&quot;,&quot;Uz&quot;,&quot;Uw&quot;,&quot;Ux&quot;,&quot;Uy&quot;,&quot;U&quot;,&quot;Uu&quot;), x = c(3, 1, 4,2,1,2,3,4,2,0.5), y = c(3,3,3,2,4,3.5,4,4,1,1.5)) dagify(X ~ Ux, Z ~ Uz, Y ~ X + Uy, W ~ Z + Uw + X, U ~ W + Uu, coords = dag7) -&gt; dagified_dsep1 図3.11: 合流点とその子、分岐点を持つ因果ダイアグラム \\(\\underline Z\\)と\\(\\underline Y\\)について \\(Z\\)と\\(Y\\)を結ぶ道は合流点 \\(W\\)を含むので全てブロックされている(= d分離されている)。しかし、\\(W\\)について条件付けすると\\(Z\\leftarrow W \\rightarrow X\\)がブロックされなくなり、\\(Z\\)は\\(X\\)の子である\\(Y\\)ともd連結になる(= 従属)。これは、\\(W\\)の子である\\(U\\)について条件付けしても同様。 しかし、\\(W\\)に加えて\\(X\\)も条件付けすると、\\(W \\leftarrow X \\rightarrow Y\\)の分岐経路がブロックされるので、\\(Z\\)と\\(Y\\)はd分離されたままである。 Rでは、\\(Z\\)と\\(Y\\)がそれぞれの変数で条件づけられたときにd分離されるかを以下のように調べられる。 ## Wで条件付け dseparated(dagified_dsep1, &quot;Z&quot;,&quot;Y&quot;, &quot;W&quot;) ## [1] FALSE ## WとXで条件付け dseparated(dagified_dsep1, &quot;Z&quot;,&quot;Y&quot;, c(&quot;W&quot;,&quot;X&quot;)) ## [1] TRUE 例2. 図3.11に\\(Z\\)と\\(Y\\)の間の分岐経路を加えたもの dag8 &lt;- tibble(name = c(&quot;X&quot;,&quot;Z&quot;,&quot;Y&quot;,&quot;W&quot;,&quot;Uz&quot;,&quot;Uw&quot;,&quot;Ux&quot;,&quot;Uy&quot;,&quot;U&quot;,&quot;Uu&quot;,&quot;T&quot;,&quot;Ut&quot;), x = c(3, 1, 4,2,1,1.8,2.25,4,2,0.5,2.5,2.5), y = c(3.3,3,3,2,4,3.2,3.2,4,1,1.5,3.9,4.5)) dagify(T ~ Ut, X ~ Ux, Z ~ T + Uz, Y ~ X + T + Uy, W ~ Z + Uw + X, U ~ W + Uu, coords = dag8) -&gt; dagified_dsep2 図3.12: 先のグラフにZとYの間の分岐経路を加えたもの \\(\\underline Z\\)と\\(\\underline Y\\)について \\(Z\\)と\\(Y\\)の間に分岐経路ができたことで、何も条件付けなければ\\(Z\\)と\\(Y\\)は従属になる(= d連結)。 \\(T\\)について条件付ければ、\\(Z\\)と\\(Y\\)の間の道はブロックされ、d分離される。 \\(T\\)に加えて\\(W\\)について条件づけると、\\(Z \\leftarrow T \\rightarrow Y\\)はブロックされるが、\\(Z \\rightarrow W \\leftarrow X \\rightarrow Y\\)は開いてしまうので、d連結になる。 さらに\\(X\\)も加えて条件付けすれば、再びd分離される。 Rでも確かめられる。 ## Tで条件付け dseparated(dagified_dsep2, &quot;Z&quot;,&quot;Y&quot;, &quot;T&quot;) ## [1] TRUE ## TとWで条件付け dseparated(dagified_dsep2, &quot;Z&quot;,&quot;Y&quot;, c(&quot;T&quot;,&quot;W&quot;)) ## [1] FALSE ## T, W, Xで条件付け dseparated(dagified_dsep2, &quot;Z&quot;,&quot;Y&quot;, c(&quot;T&quot;,&quot;W&quot;,&quot;X&quot;)) ## [1] TRUE 練習問題 図3.13で隣接していない変数の組それぞれについて、どの変数の集合で条件付き独立となるか 図3.13: 練習問題1の因果ダイアグラム A. 答えは以下の8通りである。 \\(Y\\), \\(V\\), \\(U\\)は分岐経路であり、\\(Y\\)と\\(U\\)を結ぶ道は1つしかないので、\\(Y \\mathop{\\perp\\!\\!\\!\\!\\perp} U|V\\) \\(V\\), \\(U\\), \\(T\\)は連鎖経路であり、\\(V\\)と\\(T\\)を結ぶ道は1つずつしかないので、\\(V \\mathop{\\perp\\!\\!\\!\\!\\perp} T|U\\) \\(X\\), \\(R\\), \\(S\\), \\(T\\)は連鎖経路であり、道は一つしかない。よって、\\(X \\mathop{\\perp\\!\\!\\!\\!\\perp} T|R, X \\mathop{\\perp\\!\\!\\!\\!\\perp} T|S, X \\mathop{\\perp\\!\\!\\!\\!\\perp} S|R, R \\mathop{\\perp\\!\\!\\!\\!\\perp} T|S\\) \\(V\\)は\\(Y\\)と\\(T\\)のいずれの原因にもなっているので、\\(Y\\)と\\(T\\)はおそらく従属である。しかし、\\(U\\)で条件づけると\\(V\\)と\\(T\\)が独立になり、結果的に\\(V\\)の子である\\(Y\\)と\\(T\\)も独立になる(\\(Y \\mathop{\\perp\\!\\!\\!\\!\\perp} T|U\\)) \\(V\\)で条件づけると\\(Y\\)と\\(U\\)が独立になり、結果的に\\(U\\)の子である\\(T\\)も\\(Y\\)と独立になる(\\(Y \\mathop{\\perp\\!\\!\\!\\!\\perp}T|U\\)) Rでは、すべての独立/条件付き独立の変数の集合は以下のように求められる。 # impliedConditionalIndependencies(dagified_prac1) 図3.13のモデルからデータを生成し、線形方程式\\(Y = a + bX + cZ\\)をあてはめる。傾きbを0にするには\\(Z\\)にどの変数を選べばよいか。 A. \\(Z\\)の下で\\(X\\)と\\(Y\\)が条件付き独立(d分離)になればよい。\\(T\\)以外は条件づけてもd分離されるので、\\(T\\)以外ならどれでもよい。 ## 各変数で条件づけたときにXとYがd分離されるか調べる sapply( names(dagified_prac1), function(Z) dseparated(dagified_prac1,&quot;X&quot;,&quot;Y&quot;,Z) ) ## R S T U V X Y ## TRUE TRUE FALSE TRUE TRUE TRUE TRUE 実際にモデルからデータを生成して確認する。simulateSEM()関数を用いると、モデルに基づいてデータを生成することができる。 d_prac1 &lt;- simulateSEM(# モデルの因果ダイアグラム dagified_prac1, # パス係数を0.7に設定する b.lower = 0.7, b.upper = 0.7, N = 5000) 確かに\\(T\\)で条件づけると\\(X\\)の係数は0でない。 lm(Y ~ X + T, data = d_prac1) %&gt;% model_parameters() %&gt;% data.frame() %&gt;% dplyr::select(1,2,3,9) %&gt;% kable(digits = 3, align = &quot;lccc&quot;) Parameter Coefficient SE p (Intercept) 0.011 0.013 0.391 X -0.136 0.014 0.000 T 0.405 0.014 0.000 他の変数(例えば\\(S\\)や\\(V\\))では\\(X\\)の係数はほぼ0になる。 lm(Y ~ X + S, data = d_prac1) %&gt;% model_parameters() %&gt;% data.frame() %&gt;% dplyr::select(1,2,3,9) %&gt;% kable(digits = 3, align = &quot;lccc&quot;) Parameter Coefficient SE p (Intercept) 0.011 0.014 0.417 X 0.000 0.016 0.995 S 0.015 0.016 0.351 lm(Y ~ X + V, data = d_prac1) %&gt;% model_parameters() %&gt;% data.frame() %&gt;% dplyr::select(1,2,3,9) %&gt;% kable(digits = 3, align = &quot;lccc&quot;) Parameter Coefficient SE p (Intercept) 0.007 0.01 0.497 X 0.004 0.01 0.660 V 0.695 0.01 0.000 図3.14で隣接していない変数の組それぞれについて、どの変数の集合で条件付き独立となるか 図3.14: 練習問題3の因果ダイアグラム A. 問1で挙げた組み合わせに加えて、以下でも条件付き独立になる。 \\(P\\mathop{\\perp\\!\\!\\!\\!\\perp}U|T\\) (連鎖経路) \\(P\\mathop{\\perp\\!\\!\\!\\!\\perp}V|T, P\\mathop{\\perp\\!\\!\\!\\!\\perp}V|U\\) (連鎖経路) \\(P\\mathop{\\perp\\!\\!\\!\\!\\perp}S|T\\) (連鎖経路) \\(P\\mathop{\\perp\\!\\!\\!\\!\\perp}R|S, P\\mathop{\\perp\\!\\!\\!\\!\\perp}R|T\\) (連鎖経路) \\(P\\mathop{\\perp\\!\\!\\!\\!\\perp}X|R,P\\mathop{\\perp\\!\\!\\!\\!\\perp}X|S, P\\mathop{\\perp\\!\\!\\!\\!\\perp}X|T\\) (連鎖経路) \\(P\\mathop{\\perp\\!\\!\\!\\!\\perp}Y|V,P\\mathop{\\perp\\!\\!\\!\\!\\perp}Y|U, P\\mathop{\\perp\\!\\!\\!\\!\\perp}Y|T\\) (分岐経路+連鎖経路) 以下でも確かめられる。 #impliedConditionalIndependencies(dagified_prac2) 図3.14のモデルで、方程式\\(Y = a + bX + cR + dS + eT + fP\\)をあてはめると、どの係数が0になるか。 A. \\(X,R,S,T,P\\)について、これらの変数が全て条件づけられたときに\\(Y\\)とd分離されるかを検討すればよい。以下のようにして\\(X, R, S, T, P\\)で条件づけたときに\\(Y\\)とd分離される変数を全て求められる。 \\(T\\)と\\(S\\)以外の変数はd分離されるので、係数が0になるのは\\(T\\)と\\(S\\)以外の変数である。 dseparated(dagified_prac2, &quot;Y&quot;, list(), c(&quot;X&quot;,&quot;R&quot;,&quot;S&quot;,&quot;T&quot;,&quot;P&quot;)) ## [1] &quot;P&quot; &quot;R&quot; &quot;X&quot; 実際にモデルからデータを生成して確認する。 たしかに、\\(T\\)と\\(S\\)以外は係数がほぼ0になる。 d_prac2 &lt;- simulateSEM(# モデルの因果ダイアグラム, dagified_prac2, # パス係数を0.7に設定する b.lower = 0.7, b.upper = 0.7, N = 5000) lm(Y ~ X + R + S + T + P, data = d_prac2) %&gt;% model_parameters() %&gt;% data.frame() %&gt;% dplyr::select(1,2,3,9) %&gt;% kable(digits = 3, align = &quot;lccc&quot;) Parameter Coefficient SE p (Intercept) -0.015 0.013 0.249 X -0.013 0.018 0.449 R -0.017 0.022 0.430 S -0.437 0.022 0.000 T 0.679 0.022 0.000 P -0.007 0.018 0.698 以下のダイアグラムについて、隣接しないノード全ての組について、その2つをd分離する変数の集合を答えよ(最小限必要な変数のみでよい)。 図3.15: 練習問題5の因果ダイアグラム A. 以下の通り \\(X\\)と\\(Y\\): \\(\\{ W, Z_3, Z_1 \\},\\{ W, Z_3, Z_2 \\}\\) ▶ \\(X\\)と\\(Y\\)の間の道をブロックするため、\\(W\\)\\(とZ3\\)は必ず入れる必要あり。しかし\\(Z_3\\)(= 合流点)を入れると\\(X \\leftarrow Z_1 \\rightarrow Z_3 \\leftarrow Z_2 \\rightarrow Y\\)がブロックされなくなるため、加えて\\(Z_1\\)または\\(Z_2\\)も条件づける必要がある。 \\(Y\\)と\\(Z_1\\): \\(\\{ Z_3, Z_2, X \\}, \\{ Z_3, Z_2, W \\}\\) ▶ \\(Z_1 \\rightarrow Z_3 \\rightarrow T\\)と\\(Z_1 \\rightarrow X \\rightarrow W \\rightarrow Y\\)をブロックするため\\(Z_3\\)と\\(X\\)または\\(W\\)は必ず条件づける必要あり。しかし\\(Z\\)を条件づけると\\(Z_1 \\rightarrow Z_3 \\leftarrow Z_2 \\rightarrow Y\\)がブロックされなくなるため、\\(Z_2\\)も条件づける必要がある。 \\(X\\)と\\(Z_2\\): \\(\\{ Z_1, Z_3 \\}\\) \\(W\\)と\\(Z_2\\): \\(\\{ X \\}\\), \\(\\{ Z_3, Z_1 \\}\\) \\(W\\)と\\(Z_1\\): \\(\\{ X \\}\\) \\(W\\)と\\(Z_3\\): \\(\\{ X \\}\\) 以下でも確かめられる。 #impliedConditionalIndependencies(dagified_prac3) 図3.15のモデルで\\(Z_3\\)の値から\\(Z_2\\)の値を予測する。\\(W\\)の値も使った方がよりよい予測になるか？ 一般に、\\(Z_2\\)とd分離されていない(= 独立でない)限りは、どの変数を入れても予測は向上する。しかし、\\(W\\)は\\(Z_3\\)で条件づけたとき\\(Z_2\\)とd分離されるため、\\(W\\)を入れても予測は良くならないはずである。 これは以下のシミュレーションでも確かめられる。 d_prac3 &lt;- simulateSEM(dagified_prac3, # パス係数を0.4に設定する b.lower = 0.4, b.upper = 0.4, N = 10000) ## Z3のみ m_without_W &lt;- lm(Z2 ~ Z3, data = d_prac3) ## Z3 + W m_with_W &lt;- lm(Z2 ~ Z3 + W, data = d_prac3) ## Z3 + Y m_with_Y &lt;- lm(Z2 ~ Z3 + Y, data = d_prac3) 線形モデルの決定係数\\(R^2\\)を計算すると、\\(W\\)を入れても入れなくてもほとんど変わらない。 一方、\\(Z_3\\)とd連結している(従属な)\\(Y\\)を入れると予測は向上する。 ## 決定係数を比較 compare_performance(m_without_W,m_with_W, m_with_Y) %&gt;% data.frame() %&gt;% dplyr::select(1,7,8) %&gt;% kable() Name R2 R2_adjusted m_without_W 0.1559857 0.1559012 m_with_W 0.1560372 0.1558684 m_with_Y 0.3449176 0.3447865 3.3 モデル検定と因果探索 実際の分析では、モデルから想定される条件付き独立が実際のデータでも見られるかによって、因果モデルが正しいものかを検証していく。例えば、図3.15では\\(W\\)と\\(Z_{1}\\)は\\(X\\)によりd分離されている。よって、もしこの因果モデルが正しいとすれば、以下の式で回帰分析を行ったときに、係数\\(r_1\\)は0になるはずである。 \\[ W = r_{X}X + r_{1}Z_1 \\] もし\\(r_1\\)が0でないならば、因果モデルは間違っていることになる。また、真のモデルでは\\(W\\)と\\(Z_1\\)の間に\\(X\\)ではd分離されていない道があるはずだということになる。このように、モデルにある全てのd分離の条件がデータの条件付き独立と一致するかを検討することで、モデルの検証を行える。 d分離性を利用したモデルの検証には以下の利点がある。 変数の関係を表す関数がどのような形でもグラフの構造のみから検証可能(= ノンパラメトリック) 局所的なモデルの修正を行える なお、最終的には1つではなく、複数のモデルまでしか絞り込めないのことの方が多い。これは、データにある独立性/従属性と矛盾しないような因果モデルは複数存在する場合が多いからである。このようなモデルはmarcov equivalentであるという。 例えば、以下のグラフで表されるモデルは全てmarcov equivalentである(つまり、変数間の独立/従属関係がすべて同じ)。 Marcov equivalentなモデルはggdag_equivalent_dags()を用いて求められる。 dagify(X ~ Z1, Z2 ~ Z1, Y ~ Z2 + W + X, W ~ X ) -&gt; dagified_prac4 ggdag_equivalent_dags(dagified_prac4,node_size =9, text_size = 3)+ theme_dag() 図3.16: Marcov equivalentなモデルの例 練習問題 図3.15のモデルで、もしいずれかの係数が0でないときにモデルが誤りになる\\(Y\\)の回帰式を１つ書け たとえば、図3.15のモデルで\\(X\\)と\\(Y\\)は\\(Z_2,Z_3,W\\)によってd分離される。よって、以下の回帰式で\\(X\\)の係数が0でなければモデルは誤りになる。 \\[ Y = a + bX + cZ_1 + dZ_3 + eW \\] 実際、モデルから生成したデータを用いて分析すると\\(X\\)の係数はほぼ0になる。 lm(Y ~ X + Z2 + Z3 + W, data = d_prac3) %&gt;% model_parameters() %&gt;% data.frame() %&gt;% dplyr::select(1,2,3,9) %&gt;% kable(digits = 3, align = &quot;lccc&quot;) Parameter Coefficient SE p (Intercept) -0.001 0.005 0.874 X 0.004 0.007 0.561 Z2 0.401 0.006 0.000 Z3 0.393 0.007 0.000 W 0.399 0.006 0.000 図3.15のモデルで、\\(X\\)が観測されていない場合に、もしいずれかの係数が0でないときにモデルが誤りになる\\(Z_3\\)の回帰式を１つ書け \\(X\\)が未観測のとき、条件付き独立になるのは以下の場合である。 \\(Z_3\\)と独立な変数はないため、係数が0になるような変数はない。 ## xが未観測であることにする latents(dagified_prac3) &lt;- &quot;X&quot; impliedConditionalIndependencies(dagified_prac3) ## W _||_ Z2 | Z1, Z3 ## Y _||_ Z1 | W, Z2, Z3 ## Z1 _||_ Z2 図3.15のモデルで問1のような回帰式がいくつあればモデルを完全に検証したことになるか。 このような回帰式の集合はbasis setと呼ばれ、以下のように求められる。 最後の2つは同じ2変数についてのものなので、4つの回帰式を検証すればよい。 ## Xが未観測という情報を消す latents(dagified_prac3) &lt;- c() impliedConditionalIndependencies(dagified_prac3, type = &quot;basis.set&quot;) ## W _||_ Z1, Z2, Z3 | X ## X _||_ Z2 | Z1, Z3 ## Y _||_ X, Z1 | W, Z2, Z3 ## Z1 _||_ Z2 ## Z2 _||_ Z1 例えば、一行目は以下の回帰式で検証できる。 \\(X\\)で条件づけたとき、\\(Z_1,Z_2,Z_3\\)の係数が全て0になればよい。 \\[ W = a + bX + cZ_1 + dZ_2 + eZ_3 \\] 実際、モデルから生成したデータを用いて分析すると\\(Z_1, Z_2, Z_3\\)の係数はほぼ0になる。 lm(W ~ X + Z1 + Z2 + Z3, data = d_prac3) %&gt;% model_parameters() %&gt;% data.frame() %&gt;% dplyr::select(1,2,3,9) %&gt;% kable(digits = 3, align = &quot;lccc&quot;) Parameter Coefficient SE p (Intercept) 0.001 0.009 0.932 X 0.383 0.012 0.000 Z1 0.005 0.011 0.629 Z2 0.019 0.010 0.064 Z3 -0.007 0.012 0.558 References "],["介入効果の推定.html", "4 介入効果の推定 4.1 介入とは 4.2 調整 4.3 バックドア基準 4.4 フロントドア基準", " 4 介入効果の推定 ここでは、いよいよ相関関係と因果関係をきちんと見分け、原因を変化させたときに結果に与える効果(因果効果・介入効果)の大きさを推定するための方法を学ぶ。 これまで見てきたように、変数間に相関関係があるからと言って、因果関係があるとは限らない場合が多々ある。よって、相関関係から予測される効果が実際の因果効果(介入効果)とズレることがよく起こる。 例えば、あなたは河川中の汚染物質量が底生昆虫の種数に与える影響を知るため、データを収集したとする。その結果、図4.1のようなデータが得られた(\\(X\\): 河川中の汚染物質の量, \\(Y\\): 底生昆虫の種数)。このデータだけをもとに、「底生昆虫の種数を増やすためには、河川中の汚染物質を減らすべきだ」と結論付けることはできるだろうか？ 答えはノーである。あくまでもこのデータから言えるのは、「\\(X\\)が小さいほど\\(Y\\)は大きい」ということだけであり、これは相関関係の話である。あなたが本当に知りたいのは「\\(X\\)を小さくしたときに、\\(Y\\)が大きくなる」といえるかである。 図4.1: 河川中の汚染物質量と底生昆虫の種数の関係 例えば、図4.1のデータについて、各データが川の上流域/下流域のいずれで収集されたかも記録したところ、図4.2のような結果が得られたとする。このグラフからは、データを上流/下流で収集するかが\\(X\\)と\\(Y\\)の両方に独立に影響したことで、\\(X\\)と\\(Y\\)の相関が生じた可能性が示唆される(交絡要因の影響)。このように、\\(X\\)と\\(Y\\)の相関が\\(X\\)と関係ない要因で生じているなら、\\(X\\)を変化させても\\(Y\\)は変化しないだろう。 図4.2: データ収集場所の情報も含めた河川中の汚染物質量と底生昆虫の種数の関係 図4.3のように、\\(Y\\)はデータ収集場所の影響もうけるが、それに加えて\\(X\\)の影響も部分的に受けているということもあるかもしれない(上流域/下流域それぞれでも\\(X\\)と\\(Y\\)に相関がある)。その場合、\\(X\\)を変化させれば\\(Y\\)も部分的に変化する。 図4.3: データ収集場所の情報も含めた河川中の汚染物質量と底生昆虫の種数の関係2 このように、\\(X\\)の介入効果が正しく推定できているかは、\\(Y\\)の値がどのような過程で得られるのかに大きく依存するのである。 因果効果を推定するために良く用いられる方法は、ランダム化比較試験(RCT)である。この方法では、応答(反応)変数(\\(Y\\))に影響を与える因子は、1つ(\\(X\\))を除いて固定されるか、ランダム化される。このようなとき、\\(Y\\)の変化は\\(X\\)によってのみ生じたといえるので、\\(X\\)の介入効果を正確に推定できる。 しかし、実際の研究ではRCTを行うことは不可能であることが多い(金銭的・時間的・倫理的・方法論的問題などなど…)。そのような場合、研究者は代わりにこうした操作を行わない観察研究を行うことになるが、近年の統計学の発展により、観察研究であっても適切に分析を行えば因果効果を推定できることが分かってきた。以下では、前章までに学んだことをもとに、どうすれば観察研究でも因果効果を正確に推定できるのかを学んでいく。 4.1 介入とは モデルにおいてある変数に「介入する」とは、その変数をある値に固定することを意味する(\\(\\neq\\)条件付けする)。よって、しばしば他の変数の値もそれに合わせて変化する。一方で、値を固定するので、他の変数からの影響はなくなる。 グラフでは、\\(X\\)に介入するということは、\\(X\\)に向かう辺が全て取り除かれることを表す(図4.4のAからBに変化するように)。このことからも、\\(X\\)で条件付けするときとは変数間の関係が全く違くなることが分かる。ある変数に介入する際の手順は、因果グラフの構造により異なる。 ひとことメモ \\(X\\)以外をランダム化することも、\\(X\\)へ向かう辺をすべて取り除くことに相当する。 図4.4: Xに介入したときのグラフの変化 条件付き確率(\\(P(Y = y|X = x)\\))と区別するため、\\(X\\)をある値\\(x\\)に固定(= \\(X\\)に介入)したときに\\(Y = y\\)になる確率は、以下のように書く。 \\(do\\)表記と因果ダイアグラムを用いることで、グラフが現実を正確に表現していれば、観察データのみから因果効果を推定することができる。以下では、その方法を見ていく。 \\[ P(Y = y|do(X = x)) \\] 4.2 調整 4.2.1 調整と調整化公式 それでは、\\(P(Y = y|do(X = x))\\)はどのように求めたらよいだろうか。 図4.5で、\\(Z\\)は性別、\\(X\\)は薬の投与の有無(0/1)、\\(Y\\)は回復の有無(0/1)を表すとする。 図4.5: 薬の効果を表す因果ダイアグラム 患者全員に薬を投与するという介入(\\(do(X = 1\\)))と、誰にも薬を投与しないという介入(\\(do(X = 0\\)))との比較を考える。このとき、その差は因果効果差または平均因果効果(ACE: average causal effect)と呼ばれ、以下の式で表せる。\\(X\\)と\\(Y\\)が複数の値をとる場合は、すべての組み合わせついて効果を算出する。 \\[ P(Y = 1|do(X = 1)) - P(Y =1| do(X=0)) \\] 因果効果\\(P(Y = y|do(X = x))\\)は、介入して\\(X\\)への辺を取り除いたモデル(図4.6)における条件付き確率\\(P_m(Y=y|X=x)\\)に等しい5。 図4.6: 介入後の因果ダイアグラム また、介入前と介入後のグラフにおける確率について、以下の3点が成り立つ。 \\(Z\\)を決める過程は\\(Z\\)から\\(X\\)への矢印がなくなっても変わらないので、周辺確率\\(P(Z = z)\\)は介入後も変化しない(\\(P(Z=z) = P_m(Z=z)\\))。 \\(Y\\)が\\(X\\)と\\(Z\\)によって決まる過程(つまり\\(Y = f(x,y,u_y)\\))は\\(X\\)への介入によって変わるわけではない。よって、条件付き確率\\(P(Y=y|X=x,Z=z) = P_m(Y=y|X=x,Z=z)\\)である。 介入後のグラフで\\(X\\)と\\(Z\\)はd分離されて独立なので、\\(P_m(Z=z|X=x) = P_m(Z=z)\\)が成り立つ 以上より、因果効果\\(P(Y=y|do(X=x))\\)は以下のように変形できる。 \\[ \\begin{aligned} &amp;P(Y=y|do(X=x))\\\\ &amp;= P_m(Y=y|X=x)\\\\ &amp;= \\sum_{z}P_m(Y=y|X=x,Z=z)P_m(Z=z|X=x) \\;\\;\\;\\; (全確率の公式より)\\\\ &amp;= \\sum_{z}P_m(Y=y|X=x,Z=z)P_m(Z=z) \\;\\;\\;\\; (1より)\\\\ &amp;= \\sum_{z}P(Y=y|X=x,Z=z)P(Z=z) \\;\\;\\;\\; (2と3より) \\end{aligned} \\] この式により、因果効果を介入前のグラフのデータから計算できるようになる。 この式は調整化公式と呼ばれ、ある\\(Z\\)の値について\\(X\\)と\\(Y\\)の関係を計算し、それを\\(Z\\)について平均していることが分かる。このような処理を「\\(Z\\)による調整」または「\\(Z\\)についてのコントロール」と呼ぶ6。 調整化公式の使用例: 図4.5のグラフについて、以下のデータ(表4.1)が得られているとする。 表4.1: 薬の投与に関する結果 薬投与 薬投与なし 男性 81/87が回復(93%) 234/270が回復(87%) 女性 192/263が回復(73%) 55/80が回復(69%) 全体 273/350が回復(78%) 289/350が回復(83%) このとき、平均因果効果(ACE)は以下のように求められる。なお、\\(X=1\\)は薬が投与されたこと、\\(Z=1\\)は患者が男であること、\\(Y=1\\)は患者が回復したことを表す。ACEは正の値なので、薬の効果があったことを示す。 \\[ \\begin{aligned} &amp;P(Y = 1| do(X = 1))\\\\ &amp;= P(Y=1|X=1,Z=1)P(Z=1) + P(Y=1|X=1,Z=0)P(Z=0) \\\\ &amp;= 0.93 \\times \\frac{87+270}{700} + 0.73 \\times \\frac{263+80}{700}\\\\ &amp;= 0.832\\\\ \\end{aligned} \\] \\[ \\begin{aligned} &amp;P(Y = 1| do(X = 0))\\\\ &amp;= P(Y=1|X=0,Z=1)P(Z=1) + P(Y=1|X=0,Z=0)P(Z=0) \\\\ &amp;= 0.87 \\times \\frac{87+270}{700} + 0.69 \\times \\frac{263+80}{700}\\\\ &amp;= 0.7818\\\\ \\\\ &amp;\\therefore ACE = P(Y = 1| do(X = 1)) - P(Y = 1| do(X = 0))\\\\ &amp;= 0.832 - 0.7818 = 0.0502\\\\ \\end{aligned} \\] 4.2.2 何を調整すべきか 注意すべき点は、モデルの因果構造によって、調整すべき変数の集合\\(Z\\)が異なる点である。 例えば、因果ダイアグラムが図4.7のような事例を考える(\\(X\\): 薬の投与, \\(Y\\): 回復, \\(Z\\): 血圧)。 図4.7: 薬の効果を表す因果ダイアグラム このモデルについて、因果効果\\(P(Y = 1| do(X = 1))\\)を求めたいとする。このとき、\\(Z\\)で調整すべきだろうか？\\(X\\)への介入とは、\\(X\\)に向かう辺をすべて取り除くことであった。このモデルにおいて、Xに向かう辺はそもそも存在しない。よって、もしこの因果ダイアグラムが正しいのであれば、\\(Z\\)で調整する必要はなく、以下の等式が成り立つ。 \\[ P(Y=1|do(X=1)) = P(Y=1|X=1) \\] 繰り返しになるが、\\(X\\)への介入とは、\\(X\\)に向かう辺をすべて取り除くことである。つまり、\\(X\\)に介入した際の因果効果\\(P(Y = 1| do(X = 1))\\)を求めるときに調整しなければいけないのは、\\(X\\)に向かって矢印が伸びている変数、つまり\\(X\\)の親である。 \\(X\\)の親を\\(PA(X)\\)とするとき、\\(X\\)が\\(Y\\)に及ぼす因果効果は調整化公式を用いて以下のように与えられる。なお、ここで\\(z\\)は\\(PA\\)に含まれる変数がとりうるすべての組み合わせである。 \\[ P(Y =y|do(X=x)) = \\sum_{z}P(Y=y|X=x,PA=z)P(PA=z) \\] この式の右辺は分母と分子に\\(P(X=x,Z=z)\\)をかけて割ることで、以下のように変形できる。 このとき、\\(P(X=x|PA=z)\\)は傾向スコアと呼ばれる。 \\[ P(Y =y|do(X=x)) = \\sum_{z} \\frac{P(X=x,Y=y,PA=z)}{P(X=x|PA=z)} \\] この式を用いれば、グラフとそこにある仮定を用いることで、観察データのみから因果効果を求めることができるのである。 4.3 バックドア基準 4.3.1 バックドア基準とは 以上から、\\(X\\)に介入した際の因果効果は、\\(X\\)の親さえ見つければ調整化公式によって機械的に求まると思うかもしれない。しかし、実際の分析においては、事態はそう単純ではないことが多い。なぜならば、グラフに変数の親が表示されていたとしても、測定が難しいためにすべてについて手に入らないことがしばしば生じうるからである。 それでは、どのような条件であれば観察データのみから(= 実験的介入を行わずに)因果効果を求めることができるだろうか。その判断基準として最も重要なもののひとつがバックドア基準と呼ばれるものである。バックドア基準を用いることで、因果モデルに含まれる任意の2変数\\(X\\)と\\(Y\\)について因果効果を求めるために、モデルに含まれるどの変数の集合\\(Z\\)について条件付けすべきかを知ることができる。 因果ダイアグラム\\(G\\)において、\\(X\\)から\\(Y\\)への有向道(第2.3節参照)があるとする。このとき、以下の条件を満たすノードの集合\\(Z\\)はバックドア基準を満たすという。 集合\\(Z\\)に含まれるいかなるノードも\\(X\\)の子孫ではない 因果ダイアグラムより\\(X\\)から出る矢印を除いたグラフにおいて、\\(Z\\)が\\(X\\)と\\(Y\\)をd分離する(第3.2節も参照) \\(Z\\)がバックドア基準を満たすとき、\\(X\\)が\\(Y\\)に及ぼす因果効果は\\(PA(X)\\)について調整した際と同様に、以下の式で得られる。つまり、\\(X\\)が\\(Y\\)に及ぼす因果効果は\\(Z\\)で調整することで求められる。 \\[ P(Y =y|do(X=x)) = \\sum_{z}P(Y=y|X=x,Z=z)P(Z=z) \\] 条件1は、以下の2点を含意する。 \\(X\\)と\\(Y\\)の中間変数を条件付けして道をブロックしないようにする(第3.1.1節参照) \\(X\\)と\\(Y\\)の合流点を条件付けして、\\(X\\)と\\(Y\\)の間に新しい道が開かないようにする(第3.1.3節、第3.2節参照) なお、\\(X\\)から出る矢印を除いたグラフにおいて\\(X\\)と\\(Y\\)の間に存在する道のうち、\\(X\\)と\\(Y\\)がd分離されていない(= 他の変数でブロックされていない)道をバックドアパスという。例えば、図4.8の左(A)の因果ダイアグラムでは、\\(X\\)から出る矢印を除いたグラフにおいて\\(X\\)と\\(Y\\)の間に存在する道(\\(X \\leftarrow Z_1 \\rightarrow Z_2 \\leftarrow Y\\))は合流点\\(Z_2\\)を含むので、どの変数で条件づけなくてもすでにブロックされている(= バックドアパスではない)。一方で、右(B)の因果ダイアグラムでは、\\(X\\)から出る矢印を除いたグラフにおいて\\(X\\)と\\(Y\\)の間に存在する道(\\(X \\leftarrow Z_1 \\rightarrow Z_2 \\rightarrow Y\\))はこのままの状態ではブロックされていないので、バックドアパスである。この道は、\\(Z_1\\)または\\(Z_2\\)で条件づけることでブロックできる。 すなわち、条件2は変数の集合\\(Z\\)で条件づけることで\\(X\\)と\\(Y\\)の間のバックドアパスがブロックできるとき、\\(Z\\)がバックドア基準を満たすことを表しているのである。 図4.8: バックドアパスの例 4.3.2 具体例 言葉だけではわかりにくい部分もあるので、具体例を挙げて確認していこう。 4.3.2.1 例1 例えば図4.9において、\\(X\\)から\\(Y\\)への介入効果を推定したいとする。このとき、\\(Y\\)以外に\\(X\\)の子孫となる変数は存在しないので、条件1はすでに満たされている。一方で、\\(X\\)から出る矢印を除いたグラフにおいて、\\(X\\)と\\(Y\\)の間の道は4つ存在する(\\(X \\leftarrow Z_1 \\rightarrow Y\\)、\\(Y \\leftarrow Z_2 \\rightarrow X\\)、\\(X \\leftarrow Z_1 \\rightarrow Y\\)、\\(X \\leftarrow Z_2 \\rightarrow Z_1 \\rightarrow Y\\)、\\(X \\leftarrow Z_1 \\leftarrow Z_2 \\rightarrow Y\\))。これらはいずれもブロックされていないので、バックドアパスである。 \\(Z_1\\)と\\(Z_2\\)の2つを条件づけることでバックドアパスはすべてブロックできる(= \\(X\\)と\\(Y\\)がd分離される)。よって、\\(Z_1\\)と\\(Z_2\\)がバックドア基準を満たす変数の最小の集合であり、これらで調整すれば\\(X\\)から\\(Y\\)への因果効果を推定できる。なお、ここで最小の集合とは、その集合からどのひとつの変数を取り除いても基準を満たさなくなるようなものを指す。 なお、ここに\\(Z_3\\)を含めてもバックドア基準は満たされる7。 dag13 &lt;- tibble(name = c(&quot;X&quot;,&quot;Y&quot;,&quot;Z1&quot;,&quot;Z2&quot;,&quot;Z3&quot;), x = c(1.5,1.5,2,1,0.75), y = c(0.5,0.25,0.75,0.75,0.5)) dagify(Y ~ Z1 + Z2 + Z3 + X, X ~ Z1 + Z2, Z1 ~ Z2, coords = dag13) -&gt; dagified_backdoor1 図4.9: バックドア基準の練習問題1 Rでは、dagittyパッケージのajustmentSets関数でバックドア基準を満たす変数の組を特定することができる。 adjustmentSets(dagified_backdoor1, exposure = &quot;X&quot;, outcome = &quot;Y&quot;, ## 最小の組み合わせを求める場合は &quot;minimal&quot; type = &quot;all&quot;) ## { Z1, Z2 } ## { Z1, Z2, Z3 } 4.3.2.2 例2 続いて、少し複雑だが図4.10において\\(X \\rightarrow Y\\)の介入効果を推定することを考える。まず条件1より、\\(X\\)の子である\\(Z_4\\)は調整する変数に含めてはならない。続いて、\\(X\\)から出る矢印を除いたグラフにおいて、\\(X\\)と\\(Y\\)の間の道は4つ存在する(\\(X \\leftarrow Z_2 \\rightarrow Z_5 \\leftarrow Z_3 \\rightarrow Y\\)、\\(X \\leftarrow Z_1 \\leftarrow Z_2 \\rightarrow Z_5 \\leftarrow Z_3 \\rightarrow Y\\)、\\(X \\leftarrow Z_2 \\rightarrow Z_1 \\rightarrow Y\\)、\\(X \\leftarrow Z_2 \\rightarrow Z_1 \\rightarrow Y\\)、\\(X \\leftarrow Z_1 \\rightarrow Y\\))。このうち前者2つはすでにブロックされているので、バックドアパスとなっているのは後者2つのみである。 \\(Z_1\\)で条件づけさえすればこの2つはブロックされるので、バックドア基準を満たす変数の最小の集合は\\(Z_1\\)となる(\\(Z_2\\)や\\(Z_3\\)を含めてもバックドア基準は満たされる)。一方、\\(Z_5\\)または\\(Z_6\\)で条件づける場合、\\(X \\leftarrow Z_2 \\rightarrow Z_5 \\leftarrow Z_3 \\rightarrow Y\\)の道が開いてしまう(= バックドアパスになってしまう)ので、これらに加えて\\(Z_2\\)か\\(Z_3\\)も条件づける必要がある。 dag14 &lt;- tibble(name = c(&quot;X&quot;,&quot;Y&quot;,&quot;Z1&quot;,&quot;Z2&quot;,&quot;Z3&quot;,&quot;Z4&quot;,&quot;Z5&quot;,&quot;Z6&quot;), x = c(1.5,1.5,2,1,0.75,1.5,0.9,1.2), y = c(0.5,0.05,0.75,0.75,0.2,0.25,0.4,0.4)) dagify(Y ~ Z1 + Z3 + Z4, X ~ Z1 + Z2, Z5 ~ Z2 + Z3, Z4 ~ X, Z6 ~ Z5, Z1 ~ Z2, coords = dag14) -&gt; dagified_backdoor2 図4.10: バックドア基準の練習問題2 このことは、Rでも確かめられる。 adjustmentSets(dagified_backdoor2, exposure = &quot;X&quot;, outcome = &quot;Y&quot;, ## 最小の組み合わせを求める場合は &quot;minimal&quot; type = &quot;all&quot;) ## { Z1 } ## { Z1, Z2 } ## { Z1, Z3 } ## { Z1, Z2, Z3 } ## { Z1, Z2, Z5 } ## { Z1, Z3, Z5 } ## { Z1, Z2, Z3, Z5 } ## { Z1, Z2, Z6 } ## { Z1, Z3, Z6 } ## { Z1, Z2, Z3, Z6 } ## { Z1, Z2, Z5, Z6 } ## { Z1, Z3, Z5, Z6 } ## { Z1, Z2, Z3, Z5, Z6 } 4.3.2.3 例3 最後に、因果構造の一部しかわからない例として図4.11を見てみよう。ここでは、未観測の変数\\(U\\)が存在する。まず、\\(Y\\)以外に\\(X\\)の子孫となる変数は存在しないので、条件1はすでに満たされている。続いて、\\(X\\)から出る矢印を除いたグラフにおいて、\\(X\\)と\\(Y\\)の間の道は2つ存在する(\\(X \\leftarrow Z_1 \\leftarrow U \\rightarrow Y\\)、\\(X \\leftarrow Z2 \\leftarrow U \\rightarrow Y\\))。これらはいずれもバックドアパスになっている。 これらの道は\\(Z_1\\)と\\(Z_2\\)で条件づけることでブロックされるので、バックドア基準を満たす変数の最小の集合は\\(Z_1\\)と\\(Z_2\\)である。このように、バックドア基準が満たされるかを知るために必ずしも因果構造の全体を知る必要はなく、未観測の要因があっても因果効果を推定できる。 dag15 &lt;- tibble(name = c(&quot;X&quot;,&quot;Y&quot;,&quot;Z1&quot;,&quot;Z2&quot;,&quot;U&quot;), x = c(1.5,1,1.15,1.3,0.75), y = c(0.6,0.6,0.7,0.8,0.8)) dagify(X ~ Z1 + Z2, Y ~ X + U, Z1 ~ U, Z2 ~ U, coords = dag15) -&gt; dagified_backdoor3 図4.11: バックドア基準の練習問題3 Rでもこのことは確かめられる。 latents(dagified_backdoor3) &lt;- &quot;U&quot; adjustmentSets(dagified_backdoor3, exposure = &quot;X&quot;, outcome = &quot;Y&quot;, ## 最小の組み合わせを求める場合は &quot;minimal&quot; type = &quot;canonical&quot;) ## { Z1, Z2 } 4.4 フロントドア基準 バックドア基準により、観察データのみから因果効果を推定する際にどの変数について調整すればよいかを判断できる。しかし、バックドア基準を満たさないグラフにおいても、因果効果を須知栄する方法はいくつか存在する。そのうちの一つが、フロントドア基準である。 フロントドア基準について説明するため、長年議論されてきた喫煙(\\(X\\))と肺がん(\\(Y\\))の因果関係について考える。1970年代において、喫煙と肺がんの間に相関がみられるのは、それら2つに同じ遺伝子(\\(U\\))が影響を与えているからだという主張が存在した(Pearl and Mackenzie 2018)。すなわち、先天的にタバコを吸いたくさせる遺伝子があり、その遺伝子が肺がんになる確率も高めているので、喫煙と肺がんの間に疑似的な相関が生じているという主張である(図4.12)8。 このグラフにおいて遺伝子を観察することはできないので、\\(U\\)で調整することで\\(X\\)から\\(Y\\)へのバックドアパスをブロックすることはできない。よって、このモデルでは喫煙が肺がんに及ぼす因果効果を推定することができない。 図4.12: 喫煙と肺がんの関係 しかし、ここでもう一つの測定値、患者内の灰内でのタールの蓄積量(\\(Z\\))が追加されたモデルを考える(図4.13)。このモデルはバックドア基準を満たさないが、バックドア基準を2度適用することで因果効果\\(P(Y=y|do(X=x))\\)を推定できるのである。 図4.13: 喫煙と肺がんの関係 図4.13において、\\(X\\)から\\(Z\\)へのバックドアパスは存在しない。なぜならば、\\(X \\leftarrow U \\rightarrow Y \\rightarrow Z\\)はすでに合流点\\(Y\\)でブロックされているからである。よって、\\(X\\)から\\(Z\\)への因果効果\\(P(Z = z|do(X=x))\\)は以下のように書ける(第4.2.2節参照)。 \\[ \\begin{equation} P(Z = z|do(X=x)) = P(Z=z|X=x) \\;\\;(1) \\end{equation} \\] 次に、\\(Z\\)から\\(Y\\)へのバックドアパス\\(Z \\leftarrow X \\leftarrow U \\rightarrow Y\\)は\\(X\\)で条件づけることでブロックできる。よって、\\(Z\\)から\\(Y\\)への因果効果\\(P(Y = y|do(Z=z))\\)は以下のように書ける(調整化公式より)。 \\[ P(Y=y|do(Z=z)) = \\sum_{x}P(Y=y|Z=z,X=x)P(X=x) \\;\\; (2) \\] 以上より、\\(X\\)から\\(Y\\)への因果効果(\\(P(Y=y|do(X=x))\\))は、\\(Z\\)の取りうる値\\(z\\)について総和をとることで以下のようになる。 \\[ \\begin{aligned} P(Y=y|do(X=x)) &amp;= \\sum_z P(Z = z|do(X=x))P(Y=y|do(Z=z)) \\;\\;(3) \\end{aligned} \\] 式(1)と(2)と(3)より、以下の式が導ける。なお、式(1)と式(2)の\\(x\\)は別物であるので(後者は単に足し合わせる際に使用したインデックスであるため)、後者は\\(x&#39;\\)と表記している。この式をフロントドア公式という。 \\[ P(Y=y|do(X=x)) = \\sum_z \\sum_{x&#39;} P(Y=y|Z=z,X=x&#39;)P(X=x&#39;)P(Z=z|X=x) \\] ここまでの分析は、\\(X\\)から\\(Y\\)への道が複数あるときに一般化できる。変数の集合\\(Z\\)外貨の条件を満たすとき、\\(Z\\)は\\(X\\)と\\(Y\\)についてフロントドア基準を満たす。 \\(Z\\)は\\(X\\)から\\(Y\\)への有向道をすべてブロックする \\(X\\)から\\(Z\\)へのバックドアパスが存在しない \\(Z\\)から\\(Y\\)へのすべてのバックドアパスが\\(X\\)によりブロックされている また、\\(Z\\)が\\(X\\)と\\(Y\\)についてフロントドア基準を満たし、\\(P(X,Z)&gt;0\\)であるならば、\\(X\\)から\\(Y\\)への因果効果は以下の式で与えられる。 \\[ P(Y=y|do(X=x)) = \\sum_z \\sum_{x&#39;} P(Y=y|Z=z,X=x&#39;)P(X=x&#39;)P(Z=z|X=x) \\] 4.4.1 練習問題 以下の因果ダイアグラム(4.14)を考える。 dag17 &lt;- tibble(name = c(&quot;X&quot;,&quot;Y&quot;,&quot;Z&quot;,&quot;W&quot;,&quot;A&quot;,&quot;B&quot;,&quot;C&quot;,&quot;D&quot;), x = c(0.25,0.75,0.5,0.5,0.25,0.25,0.75,0.75), y = c(0.1,0.1,0.35,0.1,0.35,0.6,0.6,0.35)) dagify(Z ~ B + C, X ~ A + Z, Y ~ Z + D + W, A ~ B, D ~ C, W ~ X, coords = dag17) -&gt; dagified_prac34 図4.14: 練習問題の因果ダイアグラム \\(X\\)から\\(Y\\)への因果効果を推定するために、バックドア基準を満たす最小の変数の集合をあげよ。 A. \\(X\\)から\\(Y\\)へのバックドアパスは\\(X \\leftarrow Z \\rightarrow Y\\) 、\\(X \\leftarrow A \\leftarrow B \\rightarrow Z \\rightarrow Y\\)、\\(X \\leftarrow Z \\leftarrow C \\rightarrow D \\rightarrow Y\\)の3つであり、これらは\\(Z\\)で条件づけることでブロックできる。しかし、\\(Z\\)で条件づけると\\(X \\leftarrow A \\leftarrow B \\rightarrow Z \\leftarrow C \\rightarrow D \\rightarrow Y\\)が開いてしまう(\\(Z\\)が合流点なので)。この道をブロックするためには、\\(A\\)、\\(B\\)、\\(C\\)、\\(D\\)のいずれかでブロックする必要がある。以上より、バックドア基準を満たす最小の変数の集合は$Z = {Z,A}, {Z,B}, {Z,C},{Z,D} $である。 これは、Rでも確かめられる。 adjustmentSets(dagified_prac34, exposure = &quot;X&quot;, outcome = &quot;Y&quot;, type = &quot;minimal&quot;) ## { D, Z } ## { C, Z } ## { B, Z } ## { A, Z } \\(D\\)と\\(W\\)から\\(Y\\)への因果効果を推定するために、バックドア基準を満たす最小の変数の集合をあげよ。 A. \\(D\\)と\\(W\\)からでる矢印を除いたグラフにおいて、バックドアパスは3つである(\\(W \\leftarrow X \\leftarrow A \\leftarrow B \\rightarrow Z \\rightarrow Y\\)、\\(W \\leftarrow X \\rightarrow Z \\rightarrow Y\\)、\\(D \\leftarrow C \\rightarrow Z \\rightarrow Y\\))。これらはいずれも\\(Z\\)で条件づければブロックできる。また、\\(X\\)と\\(C\\)について条件付けしてもこの道はブロックできる。 これは、Rでも確かめられる。 adjustmentSets(dagified_prac34, exposure = c(&quot;D&quot;,&quot;W&quot;), outcome = &quot;Y&quot;, type = &quot;minimal&quot;) ## { Z } ## { C, X } このグラフにおいて、\\(X\\)と\\(Y\\)以外に観測可能な変数が1つのみだとする。このとき、\\(X\\)から\\(Y\\)への因果効果を推定するには、どの変数を計測すればよいか。 A. 問1より、\\(X\\)から\\(Y\\)へのバックドアパスをブロックするには少なくとも2つの変数が必要である。一方で、\\(W\\)は\\(X\\)と\\(Y\\)についてフロントドア基準を満たすので、\\(W\\)さえ観測できれば因果効果は推定できる。 References "],["動作環境.html", "5 動作環境", " 5 動作環境 sessionInfo() ## R version 4.2.2 (2022-10-31 ucrt) ## Platform: x86_64-w64-mingw32/x64 (64-bit) ## Running under: Windows 10 x64 (build 22621) ## ## Matrix products: default ## ## locale: ## [1] LC_COLLATE=Japanese_Japan.utf8 LC_CTYPE=Japanese_Japan.utf8 ## [3] LC_MONETARY=Japanese_Japan.utf8 LC_NUMERIC=C ## [5] LC_TIME=Japanese_Japan.utf8 ## ## attached base packages: ## [1] stats graphics grDevices utils datasets methods base ## ## other attached packages: ## [1] knitr_1.41 ggsci_2.9 ppcor_1.1 MASS_7.3-58.1 ## [5] GGally_2.1.2 see_0.7.4 report_0.5.5 parameters_0.20.0 ## [9] performance_0.10.1 modelbased_0.8.5 insight_0.18.8 effectsize_0.8.2 ## [13] datawizard_0.6.5 correlation_0.8.3 bayestestR_0.13.0 easystats_0.6.0 ## [17] patchwork_1.1.2 ggdag_0.2.7 dagitty_0.3-1 forcats_0.5.2 ## [21] stringr_1.5.0 dplyr_1.0.10 purrr_1.0.0 readr_2.1.3 ## [25] tidyr_1.2.1 tibble_3.1.8 ggplot2_3.4.0 tidyverse_1.3.2 ## ## loaded via a namespace (and not attached): ## [1] googledrive_2.0.0 colorspace_2.0-3 ellipsis_0.3.2 ## [4] estimability_1.4.1 fs_1.5.2 rstudioapi_0.14 ## [7] farver_2.1.1 graphlayouts_0.8.4 ggrepel_0.9.2 ## [10] fansi_1.0.3 mvtnorm_1.1-3 lubridate_1.9.0 ## [13] xml2_1.3.3 codetools_0.2-18 cachem_1.0.6 ## [16] polyclip_1.10-4 jsonlite_1.8.4 broom_1.0.2 ## [19] dbplyr_2.2.1 ggforce_0.4.1 compiler_4.2.2 ## [22] httr_1.4.4 emmeans_1.8.3 backports_1.4.1 ## [25] assertthat_0.2.1 fastmap_1.1.0 gargle_1.2.1 ## [28] cli_3.6.0 tweenr_2.0.2 htmltools_0.5.4 ## [31] tools_4.2.2 igraph_1.3.5 coda_0.19-4 ## [34] gtable_0.3.1 glue_1.6.2 V8_4.2.2 ## [37] Rcpp_1.0.9 cellranger_1.1.0 jquerylib_0.1.4 ## [40] vctrs_0.5.1 ggraph_2.1.0 xfun_0.36 ## [43] rvest_1.0.3 timechange_0.1.1 lifecycle_1.0.3 ## [46] googlesheets4_1.0.1 scales_1.2.1 tidygraph_1.2.2 ## [49] hms_1.1.2 RColorBrewer_1.1-3 yaml_2.3.6 ## [52] curl_4.3.3 gridExtra_2.3 sass_0.4.4 ## [55] reshape_0.8.9 stringi_1.7.8 highr_0.10 ## [58] boot_1.3-28 rlang_1.0.6 pkgconfig_2.0.3 ## [61] evaluate_0.19 lattice_0.20-45 labeling_0.4.2 ## [64] tidyselect_1.2.0 plyr_1.8.8 magrittr_2.0.3 ## [67] bookdown_0.31 R6_2.5.1 generics_0.1.3 ## [70] DBI_1.1.3 pillar_1.8.1 haven_2.5.1 ## [73] withr_2.5.0 modelr_0.1.10 crayon_1.5.2 ## [76] utf8_1.2.2 tzdb_0.3.0 rmarkdown_2.19 ## [79] viridis_0.6.2 grid_4.2.2 readxl_1.4.1 ## [82] reprex_2.0.2 digest_0.6.31 xtable_1.8-4 ## [85] munsell_0.5.0 viridisLite_0.4.1 bslib_0.4.2 "],["404.html", "Page not found", " Page not found The page you requested cannot be found (perhaps it was moved or renamed). You may want to try searching to find the page's new location, or use the table of contents to find the page you are looking for. "]]
