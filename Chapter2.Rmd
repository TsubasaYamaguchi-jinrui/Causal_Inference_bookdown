# 2. 構造的因果モデルと因果ダイアグラムの基礎          
## 2.1 構造的因果モデル(SCM)  
変数間の因果関係を記述するためには、データセットにある変数間の因果関係についての仮定を正式に記述する必要がある。  
そこで、**構造的因果モデル(SCM: Structural Causal Model)**を導入する。  
SCMは、以下の3つによって記述される。   

- $V$: その変動理由がモデル内で記述される変数(**内生変数**)の集合    
- $U$: その変動理由がモデル内で記述されない変数(**外生変数**)の集合   
- $F$: モデル内の他の変数によって内生変数の値を決定する関数の集合  


内生変数は**少なくとも1つの外生変数を含む関数を用いて記述**される(=少なくとも1つの外生変数の子孫である)。一方で、外生変数は**他の変数によって記述できない**(=他の変数の子孫ではない)。すなわち、すべての外生変数の値が分かれば、関数$F$により全ての内生変数の値が正確に決定される。    

例: 教育レベル($X$)と職務経験($Y$)による給料($Z$)  

$U = \lbrace X, Y \rbrace, V = \lbrace Z \rbrace, F = \lbrace f_Z \rbrace$  
$$
\begin{aligned}
  f_Z: Z &= 2X + 3Y
\end{aligned}
$$

**因果の定義**[@Pearl2016]    
SCM内で$Y$の値を決定する関数に$X$が使われるとき、$X$は$Y$の**直接原因**であるという。$X$が$Y$の直接原因であるか、$Y$の原因の直接原因であるとき、$X$**は**$Y$**の原因である**という。上の例では、$X$**と**$Y$**は**$Z$**の直接原因**である。 

**ひとことメモ**  
因果関係の定義には様々な流儀があり、ここではPearl et al. (2016)の定義を紹介した。 
前述の定義とほとんど同じであるが、林・黒木(2016)は以下のように定義している。  

> 「要因$X$を人為的に変化させた(介入した)とき、要因$Y$も変化する」とき「要因$X \rightarrow Y$の因果関係がある」と呼ぶ  


## 2.2 因果ダイアグラムの概要  
因果ダイアグラムとは、図\@ref(fig:fig-graph)のように**丸(記号は何でもよいが)と矢印を用いて変数間の因果構造を表したもの**である。矢印は**因果関係**を表し、それぞれのSCMには対応する因果ダイアグラムが必ず存在する。因果ダイアグラムを活用することで、定量的なデータに依ることなくモデルの中に存在する変数の関係を表現することができるので、因果推論を行う上で非常に重要なツールである。  

先ほどの例を因果ダイアグラムで表すと以下のようになる。  

```{r, echo = FALSE, fig.dim = c(2.5,2), fig.cap = "因果ダイアグラムの例"}
dagify(Z ~ X,
       Z ~ Y,
       coords = tibble(name = c("X","Z","Y"),
                       x = c(1,2,3),
                       y = c(1.2,1,1.2))) %>% 
  ggdag(node_size =10, text_size = 3)+
  theme_dag()
```


## 2.3 因果ダイアグラムの描き方  
ここでは、Rでの因果ダイアグラムの描き方を解説する。  
まずはノード(点)の名前と位置(x,y座標)を記したデータフレーム(あるいはtibble)を作成する。  
```{r}
dag1 <- tibble(name = c("A","B","C","D"),
               x = c(1, 2, 3, 2),
               y    = c(2, 2, 2, 1))
```

その後、`gadify()`でノード間の関係を記述する。  

- `y ~ x`は`y <- x`を表す。  
- `x1 ~~ x2`は `x1 <-> x2`を表す。  

```{r}
dagified_dag1 <- dagify(A ~ B,
                      C ~ B,
                      D ~ A + C,
                      ##暴露変数の指定ができる    
                      exposure = "C",
                      ## 結果変数の指定ができる  
                      outcome = "D",
                      coords = dag1)
```

グラフの描画に必要な情報が書き込まれるよう。  
```{r}
dagified_dag1
```

`tidy_dagitty()`でデータフレームの形で出力もできる。  
```{r}
tidy_dagitty(dagified_dag1)
```

最後に、`ggplot()`を用いてダイアグラムを描画する。  
`ggdag`パッケージに含まれる関数を使用する。  
```{r fig-sample, fig.dim = c(3.5,2.3), fig.cap = "作成した因果ダイアグラム \\label{fig_sample}"}
ggplot(dagified_dag1,
       aes(x = x, y=y, xend = xend, yend = yend))+
  ## ノード、文字、エッジの設定。Dのみ色を変える 
  geom_dag_point(aes(color = name == "D"),
                 alpha = 1/2, size = 10.5, show.legend = F)+
  geom_dag_text(color = "black")+
  geom_dag_edges()+
  scale_color_manual(values = c("steelblue", "orange"))+
  ## 座標を消す
  scale_x_continuous(NULL, breaks = NULL, expand = c(.1, .1)) +
  scale_y_continuous(NULL, breaks = NULL, expand = c(.1, .1)) +
  theme_minimal() +
  theme(panel.grid = element_blank())
```

特にこだわりがなければ、`ggdag()`で容易に描ける。  
`theme_dag()`で最小限のテーマ(目盛や背景を削除)にしてくれる。  
```{r,fig.dim = c(3,2.5), fig.cap = "ggdag()で描いた因果ダイアグラム"}
ggdag(dagified_dag1, node_size =10, text_size = 3)+
  theme_dag()
```

## 2.4 因果ダイアグラムの基礎    
有向辺(方向のあるエッジ)の始点を**親**、終点を**子**と呼ぶ。  
```{r, echo = FALSE,fig.dim = c(3,1.5), fig.cap = "ノードの親子"}
dagify(B ~ A,
       coords = tibble(name = c("A","B"),
               x = c(1, 2),
               y    = c(1, 1))) %>% 
  ggdag(node_size =10, text_size = 3)+
  theme_dag()+
  coord_cartesian(ylim = c(0,2))+
  annotate(geom = "text",
           x = c(1,2), y = c(1.6,1.6), label = c("親","子"))
  
```


また、3つ以上のノードがあり、2つの有向辺が共に入ってくるノードや、2つの有向辺が共に出ていくノードがない場合(下図のようなとき)、これを**有向道**と呼ぶ。  
有向道上の最初のノードは、道上のすべてのノードの**祖先**である(下図で、CはAの**祖先**、AはCの**子孫(=孫)**である)。  

```{r, echo = FALSE,fig.dim = c(3,1.5), fig.cap = "ノードの親・子・孫"}
dag2 <- tibble(name = c("A","B","C"),
               x = c(1, 2, 3),
               y    = c(1, 1, 1))

dagify(B ~ A,
       C ~ B,
       coords = dag2) %>% 
  ggdag(node_size =10, text_size = 3)+
  coord_cartesian(ylim = c(0,2))+
  theme_dag()+
  annotate(geom = "text",
           x = c(1,2,3), y = c(1.6,1.6,1.6), label = c("親","子","孫"))
```

Rでは、`dagitty`パッケージでこれを求められる。  
図\@ref(fig:fig-sample)の因果ダイアグラムを用いて求めてみる。  

**親**  
```{r}
parents(dagified_dag1,"D")
```

**子**  
```{r}
children(dagified_dag1, "B")
```

**祖先**  
```{r}
ancestors(dagified_dag1, "D")
```

**子孫**  
```{r}
descendants(dagified_dag1, "B")
```

また、**特定の2つのノード間の有向道**は以下のように求められる。  
`directed = F`とすると有向道以外の道も調べられる。  
```{r}
paths(dagified_dag1, "B", "D", directed = T)$path
```

有向道があるノードからスタートして、それ自身に戻ってくるとき、その道とグラフは**巡回的**という。  
例えば、以下の二つのグラフは巡回的である。  
巡回的でないグラフを**非巡回的**であるという。  
```{r, echo = FALSE,fig.dim = c(5,2.5), fig.cap = "巡回的なグラフの例"}
dag3 <- tibble(name = c("B","A","C"),
               x = c(1, 2, 3),
               y    = c(1, 2, 1))

dagify(B ~ A,
       C ~ A,
       C ~ B,
       coords = dag3) %>% 
  ggdag(node_size =10, text_size = 3)+
  theme_dag()-> g_dag3_a

dagify(B ~ A,
       A ~ C,
       C ~ B,
       coords = dag3) %>% 
  ggdag(node_size =10, text_size = 3)+
  theme_dag() -> g_dag3_b

g_dag3_a + g_dag3_b
```


## 2.5 独立と従属  
2つの変数$X$と$Y$は、以下が成り立つときにそれぞれがとりうる全ての値$x$と$y$について**独立**という。すなわち、XとYが独立のとき、変数Yの値がなんであろうと、$P(X = x)$の値は変わらない(**= 相関がない**)。    

$$
P(X = x|Y = y) = p(X = x)
$$

独立は記号を用いて以下のように表せる。  

$$
X \mathop{\perp\!\!\!\!\perp}  Y
$$

また、確率変数$Z$の任意の値が与えられたときに$X$と$Y$が全ての$x$、$y$について独立のとき、$X$と$Y$は$Z$の下で**条件付き独立**であるという。  
以下のようにあらわす。  

$$
X \mathop{\perp\!\!\!\!\perp}  Y|Z
$$

因果ダイアグラム上で独立または条件付き独立であるノードは、`impliedConditionalIndependencies()`を用いて以下のように求められる(例. 図\@ref(fig:fig-sample)について)。  
```{r}
impliedConditionalIndependencies(dagified_dag1)
```

なお、独立でない2変数は**従属**であるという。  

**ひとことメモ**  
実際の分析では、例えば以下のような場合に$Z$**について条件付け**したことになる。  

- ある$Z$の値のデータのみを抽出して分析する  
- 偏相関係数: $Z$の影響を排除して他の2変数相関係数を算出する    
- 回帰分析: 説明変数に$Z$を加えて回帰分析を行う  